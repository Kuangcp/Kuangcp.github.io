<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>GitBase - Mythos · Java Developer</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Kuangcp" /><meta name="description" content="💠 Git基础 开源许可证 基本命令 3.1. config 3.2. clone 3.2.1. Shallow Clone 3.2.2. sparse checkout 稀疏检出 3.3. add 3.4. rm 3.5. status 3.6. commit 3.7. restore 3.8. revert 3.9. show 3.10. log 3.10.1. 对比两个分支的差异 3.10.2. 查看文件的修改记录 3.10.3. 全分支搜" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.99.0 with theme even" />


<link rel="canonical" href="https://www.kuangcp.top/post/skills/vcs/gitbase/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="GitBase" />
<meta property="og:description" content="💠 Git基础 开源许可证 基本命令 3.1. config 3.2. clone 3.2.1. Shallow Clone 3.2.2. sparse checkout 稀疏检出 3.3. add 3.4. rm 3.5. status 3.6. commit 3.7. restore 3.8. revert 3.9. show 3.10. log 3.10.1. 对比两个分支的差异 3.10.2. 查看文件的修改记录 3.10.3. 全分支搜" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.kuangcp.top/post/skills/vcs/gitbase/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-01-04T10:45:28+00:00" />
<meta property="article:modified_time" content="2024-01-04T10:45:28+00:00" />

<meta itemprop="name" content="GitBase">
<meta itemprop="description" content="💠 Git基础 开源许可证 基本命令 3.1. config 3.2. clone 3.2.1. Shallow Clone 3.2.2. sparse checkout 稀疏检出 3.3. add 3.4. rm 3.5. status 3.6. commit 3.7. restore 3.8. revert 3.9. show 3.10. log 3.10.1. 对比两个分支的差异 3.10.2. 查看文件的修改记录 3.10.3. 全分支搜"><meta itemprop="datePublished" content="2024-01-04T10:45:28+00:00" />
<meta itemprop="dateModified" content="2024-01-04T10:45:28+00:00" />
<meta itemprop="wordCount" content="10527">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GitBase"/>
<meta name="twitter:description" content="💠 Git基础 开源许可证 基本命令 3.1. config 3.2. clone 3.2.1. Shallow Clone 3.2.2. sparse checkout 稀疏检出 3.3. add 3.4. rm 3.5. status 3.6. commit 3.7. restore 3.8. revert 3.9. show 3.10. log 3.10.1. 对比两个分支的差异 3.10.2. 查看文件的修改记录 3.10.3. 全分支搜"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Mythos</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Mythos</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">GitBase</h1>

      <div class="post-meta">
        <span class="post-time"> 2024-01-04 </span>
        
          <span class="more-meta"> 10527 words </span>
          <span class="more-meta"> 22 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#git基础">Git基础</a></li>
    <li><a href="#开源许可证">开源许可证</a></li>
    <li><a href="#基本命令">基本命令</a>
      <ul>
        <li><a href="#config">config</a></li>
        <li><a href="#clone">clone</a>
          <ul>
            <li><a href="#shallow-clone">Shallow Clone</a></li>
            <li><a href="#sparse-checkout-稀疏检出">sparse checkout 稀疏检出</a></li>
          </ul>
        </li>
        <li><a href="#add">add</a></li>
        <li><a href="#rm">rm</a></li>
        <li><a href="#status">status</a></li>
        <li><a href="#commit">commit</a></li>
        <li><a href="#restore">restore</a></li>
        <li><a href="#revert">revert</a></li>
        <li><a href="#show">show</a></li>
        <li><a href="#log">log</a>
          <ul>
            <li><a href="#对比两个分支的差异">对比两个分支的差异</a></li>
            <li><a href="#查看文件的修改记录">查看文件的修改记录</a></li>
            <li><a href="#全分支搜索字符串">全分支搜索字符串</a></li>
            <li><a href="#查看目录或文件修改频次">查看目录或文件修改频次</a></li>
          </ul>
        </li>
        <li><a href="#blame">blame</a></li>
        <li><a href="#diff">diff</a>
          <ul>
            <li><a href="#diff-创建-patch">diff 创建 patch</a></li>
          </ul>
        </li>
        <li><a href="#apply">apply</a></li>
        <li><a href="#format-patch">format-patch</a></li>
        <li><a href="#am">am</a></li>
        <li><a href="#tag">tag</a></li>
        <li><a href="#notes">notes</a></li>
        <li><a href="#reset">reset</a>
          <ul>
            <li><a href="#回滚add操作">回滚add操作</a></li>
            <li><a href="#回滚最近一次commit">回滚最近一次commit</a></li>
            <li><a href="#回滚最近几次的commit并添加到一个新建的分支上去">回滚最近几次的commit并添加到一个新建的分支上去</a></li>
            <li><a href="#回滚merge和pull操作">回滚merge和pull操作</a></li>
            <li><a href="#在index已有修改的状态回滚merge或者pull">在index已有修改的状态回滚merge或者pull</a></li>
            <li><a href="#被中断的工作流程">被中断的工作流程</a></li>
          </ul>
        </li>
        <li><a href="#gc">gc</a></li>
        <li><a href="#clean">clean</a></li>
      </ul>
    </li>
    <li><a href="#本地分支">本地分支</a>
      <ul>
        <li><a href="#show-branch">show-branch</a></li>
        <li><a href="#stash">stash</a>
          <ul>
            <li><a href="#stash-创建-patch">stash 创建 patch</a></li>
            <li><a href="#恢复被drop的stash">恢复被drop的stash</a></li>
          </ul>
        </li>
        <li><a href="#branch">branch</a></li>
        <li><a href="#checkout">checkout</a></li>
        <li><a href="#分支合并">分支合并</a>
          <ul>
            <li><a href="#分支问题排查">分支问题排查</a></li>
          </ul>
        </li>
        <li><a href="#merge">merge</a></li>
        <li><a href="#rebase">rebase</a></li>
        <li><a href="#cherry-pick">cherry-pick</a></li>
        <li><a href="#bisect">bisect</a></li>
        <li><a href="#worktree">worktree</a></li>
      </ul>
    </li>
    <li><a href="#远程操作">远程操作</a>
      <ul>
        <li><a href="#remote">remote</a></li>
        <li><a href="#push">push</a></li>
        <li><a href="#fetch">fetch</a></li>
        <li><a href="#pull">pull</a></li>
      </ul>
    </li>
    <li><a href="#submodule">Submodule</a></li>
    <li><a href="#其他">其他</a>
      <ul>
        <li><a href="#gitk">gitk</a></li>
        <li><a href="#grep">grep</a></li>
        <li><a href="#archive">archive</a></li>
        <li><a href="#reflog">reflog</a></li>
        <li><a href="#rev-parse">rev-parse</a></li>
        <li><a href="#scalar">scalar</a></li>
        <li><a href="#githooks">githooks</a></li>
      </ul>
    </li>
    <li><a href="#配置文件">配置文件</a>
      <ul>
        <li><a href="#gitignore">gitignore</a></li>
        <li><a href="#gitattributes">gitattributes</a></li>
      </ul>
    </li>
    <li><a href="#自定义插件">自定义插件</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>💠</p>
<ul>
<li>
<ol>
<li><a href="#git%E5%9F%BA%E7%A1%80">Git基础</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="#%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81">开源许可证</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">基本命令</a></li>
</ol>
<ul>
<li>3.1. <a href="#config">config</a></li>
<li>3.2. <a href="#clone">clone</a>
<ul>
<li>3.2.1. <a href="#shallow-clone">Shallow Clone</a></li>
<li>3.2.2. <a href="#sparse-checkout-%E7%A8%80%E7%96%8F%E6%A3%80%E5%87%BA">sparse checkout 稀疏检出</a></li>
</ul>
</li>
<li>3.3. <a href="#add">add</a></li>
<li>3.4. <a href="#rm">rm</a></li>
<li>3.5. <a href="#status">status</a></li>
<li>3.6. <a href="#commit">commit</a></li>
<li>3.7. <a href="#restore">restore</a></li>
<li>3.8. <a href="#revert">revert</a></li>
<li>3.9. <a href="#show">show</a></li>
<li>3.10. <a href="#log">log</a>
<ul>
<li>3.10.1. <a href="#%E5%AF%B9%E6%AF%94%E4%B8%A4%E4%B8%AA%E5%88%86%E6%94%AF%E7%9A%84%E5%B7%AE%E5%BC%82">对比两个分支的差异</a></li>
<li>3.10.2. <a href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9%E8%AE%B0%E5%BD%95">查看文件的修改记录</a></li>
<li>3.10.3. <a href="#%E5%85%A8%E5%88%86%E6%94%AF%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B2">全分支搜索字符串</a></li>
<li>3.10.4. <a href="#%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E9%A2%91%E6%AC%A1">查看目录或文件修改频次</a></li>
</ul>
</li>
<li>3.11. <a href="#blame">blame</a></li>
<li>3.12. <a href="#diff">diff</a>
<ul>
<li>3.12.1. <a href="#diff-%E5%88%9B%E5%BB%BA-patch">diff 创建 patch</a></li>
</ul>
</li>
<li>3.13. <a href="#apply">apply</a></li>
<li>3.14. <a href="#format-patch">format-patch</a></li>
<li>3.15. <a href="#am">am</a></li>
<li>3.16. <a href="#tag">tag</a></li>
<li>3.17. <a href="#notes">notes</a></li>
<li>3.18. <a href="#reset">reset</a>
<ul>
<li>3.18.1. <a href="#%E5%9B%9E%E6%BB%9Aadd%E6%93%8D%E4%BD%9C">回滚add操作</a></li>
<li>3.18.2. <a href="#%E5%9B%9E%E6%BB%9A%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit">回滚最近一次commit</a></li>
<li>3.18.3. <a href="#%E5%9B%9E%E6%BB%9A%E6%9C%80%E8%BF%91%E5%87%A0%E6%AC%A1%E7%9A%84commit%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E5%BB%BA%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8A%E5%8E%BB">回滚最近几次的commit并添加到一个新建的分支上去</a></li>
<li>3.18.4. <a href="#%E5%9B%9E%E6%BB%9Amerge%E5%92%8Cpull%E6%93%8D%E4%BD%9C">回滚merge和pull操作</a></li>
<li>3.18.5. <a href="#%E5%9C%A8index%E5%B7%B2%E6%9C%89%E4%BF%AE%E6%94%B9%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%9E%E6%BB%9Amerge%E6%88%96%E8%80%85pull">在index已有修改的状态回滚merge或者pull</a></li>
<li>3.18.6. <a href="#%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">被中断的工作流程</a></li>
</ul>
</li>
<li>3.19. <a href="#gc">gc</a></li>
<li>3.20. <a href="#clean">clean</a></li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">本地分支</a></li>
</ol>
<ul>
<li>4.1. <a href="#show-branch">show-branch</a></li>
<li>4.2. <a href="#stash">stash</a>
<ul>
<li>4.2.1. <a href="#stash-%E5%88%9B%E5%BB%BA-patch">stash 创建 patch</a></li>
<li>4.2.2. <a href="#%E6%81%A2%E5%A4%8D%E8%A2%ABdrop%E7%9A%84stash">恢复被drop的stash</a></li>
</ul>
</li>
<li>4.3. <a href="#branch">branch</a></li>
<li>4.4. <a href="#checkout">checkout</a></li>
<li>4.5. <a href="#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6">分支合并</a>
<ul>
<li>4.5.1. <a href="#%E5%88%86%E6%94%AF%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5">分支问题排查</a></li>
</ul>
</li>
<li>4.6. <a href="#merge">merge</a></li>
<li>4.7. <a href="#rebase">rebase</a></li>
<li>4.8. <a href="#cherry-pick">cherry-pick</a></li>
<li>4.9. <a href="#bisect">bisect</a></li>
<li>4.10. <a href="#worktree">worktree</a></li>
</ul>
</li>
<li>
<ol start="5">
<li><a href="#%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C">远程操作</a></li>
</ol>
<ul>
<li>5.1. <a href="#remote">remote</a></li>
<li>5.2. <a href="#push">push</a></li>
<li>5.3. <a href="#fetch">fetch</a></li>
<li>5.4. <a href="#pull">pull</a></li>
</ul>
</li>
<li>
<ol start="6">
<li><a href="#submodule">Submodule</a></li>
</ol>
</li>
<li>
<ol start="7">
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ol>
<ul>
<li>7.1. <a href="#gitk">gitk</a></li>
<li>7.2. <a href="#grep">grep</a></li>
<li>7.3. <a href="#archive">archive</a></li>
<li>7.4. <a href="#reflog">reflog</a></li>
<li>7.5. <a href="#rev-parse">rev-parse</a></li>
<li>7.6. <a href="#scalar">scalar</a></li>
<li>7.7. <a href="#githooks">githooks</a></li>
</ul>
</li>
<li>
<ol start="8">
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
</ol>
<ul>
<li>8.1. <a href="#gitignore">gitignore</a></li>
<li>8.2. <a href="#gitattributes">gitattributes</a></li>
</ul>
</li>
<li>
<ol start="9">
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6">自定义插件</a></li>
</ol>
</li>
</ul>
<p>💠 2024-11-11 17:02:19</p>
<hr>
<h1 id="git基础">Git基础</h1>
<blockquote>
<p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. &ndash; <a href="https://git-scm.com/">git-scm.com</a></p>
</blockquote>
<blockquote>
<p><a href="https://git-scm.com/docs">Official Doc: git</a> | <a href="https://github.com/git/git">Github:git</a> | <a href="https://wiki.archlinux.org/index.php/Git">Arch Wiki: Git</a> | <a href="https://gitee.com/all-about-git">Gitee: about git</a> | <a href="https://npm.taobao.org/mirrors/git-for-windows/">git-for-windows 安装包镜像源</a></p>
</blockquote>
<ul>
<li>index stage work 三个逻辑分区
<ul>
<li>index: 已经 commit 的内容, 不可更改历史commit</li>
<li>stage: 执行 add 命令, 将文件缓存到该区</li>
<li>work: 工作目录, 日常做修改的就是该分区</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://git-scm.com/docs/gitworkflows">gitworkflows Documentation</a></p>
</blockquote>
<hr>
<ul>
<li><a href="https://git-lfs.github.com/">Git LFS</a> large file system</li>
</ul>
<blockquote>
<p>防止Git仓库存储爆炸</p>
</blockquote>
<ul>
<li>不提交源码无关文件： 编译后结果，二进制文件，日志</li>
<li>源码中单文件不要太大： 每次修改都会存储该文件的快照，文件大且修改频繁的话会快速占用空间</li>
</ul>
<blockquote>
<p><a href="/Skills/Vcs/GitAction.md#%E6%B8%85%E7%90%86%E4%BB%93%E5%BA%93%E5%A4%A7%E6%96%87%E4%BB%B6">清理大文件</a></p>
</blockquote>
<h1 id="开源许可证">开源许可证</h1>
<blockquote>
<p><a href="/Skills/Document/License.md">License</a></p>
</blockquote>
<hr>
<h1 id="基本命令">基本命令</h1>
<blockquote>
<p><a href="https://github.com/521xueweihan/git-tips">git-tips</a> <code>学习Git的仓库</code><br>
<a href="https://github.com/gotgit">git权威指南的组织</a> <code>完整书籍,以及相关测试题</code></p>
</blockquote>
<blockquote>
<p><a href="https://coding.net/help/doc/practice/git-principle.html">使用原理视角看 Git</a><br>
<a href="https://zhuanlan.zhihu.com/p/30561653">如何高效地使用 Git</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.techug.com/post/review-of-linus-torvalds-on-git.html">参考: 重看”Linus Torvalds on Git”视频</a><br>
<a href="https://github.com/tiimgreen/github-cheat-sheet">GitHub Cheat Sheet</a></p>
</blockquote>
<blockquote>
<p>使用 <code>git help 子命令</code>, 就能看到子命令对应的文档</p>
</blockquote>
<h2 id="config">config</h2>
<ul>
<li>三种配置方式 作用范围越大, 生效优先级越低
<ul>
<li><code>--system</code> 作用所有用户, 对应文件 <code>/etc/gitconfig</code></li>
<li><code>--global</code> 作用当前用户, 对应文件 <code>~/.gitconfig</code></li>
<li>(缺省) <code>--local</code>作用当前项目, 对应文件 <code>./.git/gitconfig</code></li>
</ul>
</li>
<li><code>git config user.email ***</code>  和   <code>git config user.name ***</code> 这两个是必须的，</li>
<li><code>git config http.postBuffer 524288000</code> 设置缓存区大小为 500m</li>
<li><code>git config core.fileMode false</code> 忽略文件的mode变化，一般发生在文件放在挂载盘的时(默认755)</li>
<li><code>git config branch.master.description</code> <strong>查看</strong>master分支描述信息，命令后附带信息则是<strong>设置</strong></li>
</ul>
<p>打开 <code>~/.gitconfig</code>文件能够发现这是 ini 格式的配置文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ini" data-lang="ini"><span class="line"><span class="cl"><span class="k">[user]</span>
</span></span><span class="line"><span class="cl">    <span class="na">email</span> <span class="o">=</span> <span class="s">kuangcp@aliyun.com
</span></span></span><span class="line"><span class="cl"><span class="s">    name = kuangcp</span>
</span></span><span class="line"><span class="cl"><span class="k">[core]</span>
</span></span><span class="line"><span class="cl">    <span class="na">quotepath</span> <span class="o">=</span> <span class="s">false # 配置路径显示为中文
</span></span></span><span class="line"><span class="cl"><span class="s">    autocrlf = false
</span></span></span><span class="line"><span class="cl"><span class="s">    safecrlf = false</span>
</span></span><span class="line"><span class="cl"><span class="k">[credential]</span>
</span></span><span class="line"><span class="cl">    <span class="na">helper</span> <span class="o">=</span> <span class="s">store</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<p><code>diff</code>配置</p>
<blockquote>
<p>可用： opendiff kdiff3 tkdiff xxdiff meld kompare gvimdiff diffuse diffmerge ecmerge p4merge araxis bc codecompare smerge vimdiff emerge
<a href="/Linux/Base/LinuxFile.md#%E6%AF%94%E8%BE%83%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">工具 详细</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/dandavison/delta">delta</a> <code>diff和分页查看git差异</code></p>
</blockquote>
<hr>
<ol>
<li>git config pull.rebase false  # merge (the default strategy)</li>
<li>git config pull.rebase true   # rebase</li>
<li>git config pull.ff only       # fast-forward only</li>
</ol>
<hr>
<h2 id="clone">clone</h2>
<ul>
<li><code>git clone URL 目录</code> 克隆下来后更名为指定目录</li>
<li><code>-b branch</code> 克隆远程仓库的指定分支  <strong>从Git 1.7.10开始支持</strong></li>
<li><code>--single-branch</code> 只克隆当前分支</li>
<li><code>git clone --depth n URL</code> 只克隆最近n次提交的历史, 能大大减小拉取的大小</li>
</ul>
<p>只克隆 指定标签或分支 且不包含内容 <code>git clone -b &lt;tag_name&gt; --single-branch --depth 1 &lt;repo_url&gt;</code> <strong>大大缩减需下载的仓库大小</strong></p>
<h3 id="shallow-clone">Shallow Clone</h3>
<p>Shallow Clone： <code>git clone --depth n URL</code> 克隆的本地仓库</p>
<blockquote>
<p>限制：</p>
</blockquote>
<ul>
<li>但是如果要新建一个分支, 并推送过去，会报错:<code>shallow update not allowed</code></li>
<li>拉取远程分支到本地不能直接用 <code>git checkout -b branch origin/branch</code> 的方式，
<ul>
<li>只能用 <code>git fetch origin branch:branch</code></li>
<li>并且跟踪远程也需手动执行 <code>git push -u origin branch</code></li>
<li>并且 git log 的输出不会显示 origin/branch 的指针信息，需要在对应分支上手动执行 <code>git remote set-branches origin branch</code> 再 <code>git fetch</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>转为完整库的方案：</p>
</blockquote>
<ol>
<li><code>git fetch --unshallow</code> 转换为完整仓库</li>
<li>补全历史提交 <code>git remote set-branches origin '*'</code> 然后 <code>git pull</code> 就会拉取最新所有分支成为可正常checkout的仓库，但仍旧残缺</li>
<li>篡改初始提交，丢弃残缺提交前的提交历史
<ul>
<li>残缺库的第一个提交会有一个 <code>graft</code>的标记</li>
<li>START_COMMIT=$(git rev-list master|tail -n 1)</li>
<li>git checkout &ndash;orphan temp_branch</li>
<li>git commit -m &ldquo;Initial commit&rdquo;</li>
<li>git rebase &ndash;onto temp_branch $START_COMMIT master</li>
<li>此时第一个提交hash变化了，graft也消失了，这个提交就成了正常的原始提交</li>
<li>但是注意这个问题：假如master分支做了以上操作，其他同样是残缺提交作为第一个提交的分支（例如dev分支）会无法merge和rebase，push 即已作废，无法修复。 所以需要找一个有最完整提交的分支执行以上操作，然后作废其他同源分支。</li>
<li>如果其他分支（feature/xxx-1.0）都是残缺提交节点后创建的，那就不受影响，因为 git merge-base 会检查到两个分支的祖先节点是一致的，能正常merge和push。</li>
</ul>
</li>
<li>简单粗暴：删除 .git 目录，从头开始</li>
</ol>
<h3 id="sparse-checkout-稀疏检出">sparse checkout 稀疏检出</h3>
<blockquote>
<p><a href="https://www.jianshu.com/p/680f2c6c84de">参考: git sparse checkout (稀疏检出)</a></p>
</blockquote>
<ol>
<li>git init name</li>
<li>cd name</li>
<li>git remote add origin URL</li>
<li>git config core.sparsecheckout true</li>
<li>echo &ldquo;path1/&rdquo; &raquo; .git/info/sparse-checkout</li>
<li>echo &ldquo;path2/&rdquo; &raquo; .git/info/sparse-checkout</li>
<li>git pull origin master</li>
</ol>
<p>此时，只会从remote端pull下来符合 sparse-checkout 文件内规则(与 .gitignore 写法一致)的目录或文件，适合拉取大仓库中的局部目录和文件</p>
<hr>
<h2 id="add">add</h2>
<ul>
<li>添加文件或目录 <code>git add file dir ...</code></li>
<li>添加当前文件夹以及子文件夹 <code>git add .</code></li>
<li>交互式添加每个文件的每部分修改 <code>git add -p</code></li>
</ul>
<hr>
<h2 id="rm">rm</h2>
<ul>
<li>删除文件 <code>git rm file1 file2 ...</code></li>
<li>仅从git仓库中删除文件, 但是文件系统中保留文件 <code>git rm --cached 文件</code>
<ul>
<li>如果仅仅是想从仓库中剔除, 那么执行完命令还要在 <code>.gitignore</code> 文件中注明, 不然又add回去了</li>
</ul>
</li>
</ul>
<hr>
<h2 id="status">status</h2>
<blockquote>
<p>git status &ndash;help 查看详细介绍</p>
</blockquote>
<ul>
<li><code>-s --short</code> 简化输出
<ul>
<li>?? 表示新添加未跟踪</li>
<li>A 新添加到暂存区</li>
<li>M 修改过的文件</li>
<li>MM 修改了但是没有暂存</li>
</ul>
</li>
</ul>
<hr>
<h2 id="commit">commit</h2>
<blockquote>
<p><a href="https://git-scm.com/docs/git-commit">Official Doc</a></p>
</blockquote>
<ul>
<li><code>git commit -am &quot;init&quot; </code>: a git库已有文件的修改进行添加, m 注释
<ul>
<li><code>git add * </code> 如果有新建立文件就要add 再之后commit就不要a参数了 <code>git commit -m &quot;&quot;</code></li>
<li>如果只是修改文件没有新建 <code>git commit -am &quot;&quot;</code></li>
</ul>
</li>
<li><code>git commit </code> 会自动进入VI编辑器
<ul>
<li>第一行：用一行文字简述提交的更改内容</li>
<li>第二行：空行</li>
<li>第三行：记述更改的原因和详细内容</li>
<li>使用下面方法关闭退出</li>
</ul>
</li>
<li><code>--amend</code> 追加文件到上次commit
<ul>
<li>如果上次提交漏了文件, 只需把漏的文件加入到 index区中, 然后执行 git commit &ndash;amend 即可</li>
<li>注意: 如果没有将前一个提交推送到远程, 那么没有任何影响,</li>
<li>如果已经推送上去了, 就相当于该次 &ndash;amend 操作是新开了个分支完成的修改, git log 里会出现一个分支的环</li>
</ul>
</li>
<li><code>--no-edit</code> 沿用上次 commit msg</li>
<li><code>--allow-empty</code> 提交空提交</li>
</ul>
<blockquote>
<p><a href="https://github.com/orhun/git-cliff">git-cliff</a><code>从commit信息中提取 changelog</code></p>
</blockquote>
<hr>
<h2 id="restore">restore</h2>
<ul>
<li>丢弃所有改动，将 Readme.md
<ul>
<li>回滚到 master倒数第三个 commit <code>git restore -s master~2 Readme.md</code></li>
<li>回滚至指定提交 <code>git restore -s commitid filepath</code></li>
</ul>
</li>
<li>撤销所有Java文件修改 <code>git restore '*.java'</code> 注意支持 regex</li>
<li>撤销工作目录所有修改 <code>git restore :/</code></li>
</ul>
<hr>
<h2 id="revert">revert</h2>
<blockquote>
<p><a href="https://git-scm.com/docs/git-revert">Doc</a></p>
</blockquote>
<ol>
<li>取消所有暂存 <code>git revert .</code></li>
<li>回滚上一次提交 <code>git revert HEAD</code></li>
<li>撤销某次提交 <code>git revert commitId</code> 注意该操作可嵌套 即 撤销撤销某次提交</li>
<li>回滚代码至指定提交 <code>git revert --no-commit 032ac94ad...HEAD</code>
<ul>
<li><code>git commit -m &quot;rolled back&quot;</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>场景: 一个特性分支不该合并到主开发分支, 但是已经合并了, 并且合并后又做了很多其他修改, 这时候怎么影响最小地撤销这次错误的合并?</p>
</blockquote>
<ol>
<li>找到 merge 的 commitId，git show commitId 找到 Merge: 后两个commitId 分别记为 1 2</li>
<li>如果保留1, 删除2节点提交的内容 则 <code>git revert commitId -m 1</code></li>
</ol>
<hr>
<h2 id="show">show</h2>
<blockquote>
<p>展示提交的详细信息 注意show和 diff 的输出仅仅相似 不可用于 patch</p>
</blockquote>
<ul>
<li>显示当前提交的差异 <code>git show HEAD</code>
<ul>
<li>HEAD替换成具体的 commit id就是显示指定提交的修改内容</li>
<li>注意这里有个 <code>^</code> 语法 HEAD^ 就是HEAD的前一次，两个就是前两次，commit id 同理</li>
<li>还有一个 <code>~</code> 语法 例如 ~2 ~3 就等价于 ^^ ^^^
<ul>
<li>特别注意 <code>git show HEAD~2^2</code> 表示取第前两次提交的第二个父提交， 如果这是一个merge节点的话，否则会报错</li>
<li><code>第一父提交</code>是合并时所在分支，<code>第二父提交</code>是所合并的分支</li>
</ul>
</li>
<li>可借助 git reflog 命令的输出找到对应的位置 例如 <code>HEAD{10}</code></li>
</ul>
</li>
<li>模糊搜索 <code>git show :/query</code></li>
</ul>
<hr>
<h2 id="log">log</h2>
<blockquote>
<p>更多说明 查看 <code>git help log</code> | <a href="https://www.git-scm.com/docs/git-log">Official Doc</a></p>
</blockquote>
<ul>
<li>
<p><code>-g</code> 包含 reflog 信息</p>
</li>
<li>
<p><code>-p</code> 显示所有提交的修改内容 <code>git log -p -2</code> 则仅显示最近两次提交的差异</p>
</li>
<li>
<p><code>--stat</code> 查看每一次提交的修改文件修改概述 （pull时看到的那些++&ndash;的内容）</p>
<ul>
<li>默认超过80会折叠成.. 可以手动指定宽度</li>
</ul>
</li>
<li>
<p><code>---pretty=[online/short/full/fuller/format]</code> 使用预定义格式显示</p>
<ul>
<li>format 可自定义格式和占位符 详情查看 -h</li>
</ul>
</li>
<li>
<p>图形的样子显示分支图 <code>--graph</code></p>
</li>
<li>
<p>显示每个分支最近的提交 <code>--simplify-by-decoration</code></p>
</li>
<li>
<p>输出简短且唯一的 SHA-1 值 <code>--abbrev-commit</code></p>
<ul>
<li>注意 SHA-1 20 byte长度 出现冲突的概率是 (n*(n-1)/2) / 2^160</li>
</ul>
</li>
<li>
<p><code>git log --author='A' </code>输出所有A开头的作者日志</p>
</li>
<li>
<p><code>git log 文件名 文件名</code> 输出更改指定文件的所有commit 要文件在当前路径才可</p>
</li>
<li>
<p><code>git log --after='2016-03-23 9:20' --before='2017-05-10 12:00' </code> 输出指定日期的日志</p>
</li>
<li>
<p><code>git shortlog</code> 按字母顺序输出每个人的日志</p>
<ul>
<li><code>--numbered</code> 按提交数排序</li>
<li><code>-s</code> 只显示每个提交者以及提交数量</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong><code>彩色输出Log</code></strong></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">    <span class="nb">alias</span> <span class="nv">glogc</span><span class="o">=</span><span class="s2">&#34;git log --graph --pretty=format:&#39;%Cred%h%Creset %Cgreen%ad%Creset | %C(bold cyan)&lt;%an&gt;%Creset %C(yellow)%d%Creset %s &#39; --abbrev-commit --date=short&#34;</span> <span class="c1"># 彩色输出</span>
</span></span><span class="line"><span class="cl">    <span class="nb">alias</span> <span class="nv">gloga</span><span class="o">=</span><span class="s1">&#39;git log --oneline --decorate --graph --all&#39;</span> <span class="c1"># 简短彩色输出</span>
</span></span><span class="line"><span class="cl">    <span class="nb">alias</span> <span class="nv">glo</span><span class="o">=</span><span class="s1">&#39;git log --oneline --decorate&#39;</span> <span class="c1"># 最简单</span>
</span></span><span class="line"><span class="cl">    <span class="nb">alias</span> <span class="nv">glol</span><span class="o">=</span><span class="s1">&#39;git log --graph --pretty=&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39;</span><span class="se">\&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">alias</span> <span class="nv">glola</span><span class="o">=</span><span class="s1">&#39;git log --graph --pretty=&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39;</span><span class="se">\&#39;</span><span class="s1">&#39; --all&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="对比两个分支的差异">对比两个分支的差异</h3>
<blockquote>
<p><a href="http://blog.csdn.net/u011240877/article/details/52586664">参考博客 git 对比两个分支差异</a></p>
</blockquote>
<blockquote>
<p>commit差异</p>
</blockquote>
<ul>
<li>
<p>查看<strong>dev有，master没有</strong>的那些提交</p>
<ul>
<li><code>git log master..dev</code> 或 <code>git log dev ^master</code> (^表示非，等价于 &ndash;not)</li>
<li>且支持多个分支 <code>git log dev ^master ^fea/feature1</code> 表示：在dev有后两个分支没有的commit</li>
<li>还可对比远程分支和本地分支的差别 <code>git log origin/master..master</code></li>
</ul>
</li>
<li>
<p>对比分支的差异： <code>git log dev...master</code> 即 非两个分支共有的commit</p>
<ul>
<li>显示出每个提交是在哪个分支上 <code>git log --left-right dev...master</code></li>
<li>注意输出： commit 后面的箭头，根据我们在 <code>–left-right dev…master</code> 的顺序，左箭头 &lt; 表示是dev的提交，右箭头 &gt; 表示是 master的。</li>
</ul>
</li>
<li>
<p>对比两个tag差异 <code>git log -s &quot;v1.1.0&quot; &quot;^v1.0.6&quot;</code></p>
</li>
</ul>
<blockquote>
<p>内容差异</p>
</blockquote>
<ul>
<li><code>git diff dev master</code> 查看 从dev分支切换到master分支将会发生的所有修改内容
<ul>
<li>第一个分支可省略，缺省为当前分支</li>
</ul>
</li>
</ul>
<h3 id="查看文件的修改记录">查看文件的修改记录</h3>
<ol>
<li><code>git log fileName</code> 或者 <code>git log --pretty=oneline fileName</code> 更容易看到 sha-1 值</li>
<li>git show sha-1的值 就能看到该次提交的所有修改</li>
</ol>
<h3 id="全分支搜索字符串">全分支搜索字符串</h3>
<p>git log &ndash;oneline -S &ldquo;search keyword&rdquo; &ndash;source &ndash;all</p>
<h3 id="查看目录或文件修改频次">查看目录或文件修改频次</h3>
<blockquote>
<p>查看所有提交修改的模块分布 <code>git --no-pager log --format=format:'%h' --no-merges | awk '{system(&quot; git --no-pager diff  --stat-name-width=300 --name-only &quot;$1&quot; &quot;$1&quot;~&quot;) }' | sed 's/\/.*//g' | sort | uniq -c | sort -hr</code></p>
</blockquote>
<ul>
<li><code>--stat-name-width=300</code> 规避路径过长被折叠成&hellip;</li>
<li>awk 中的 system() 调用命令</li>
<li><code>sed 's/\/.*//g'</code> 只保留第一级目录</li>
<li><code>--after='2022-01-01 0:00' --before='2023-01-01 0:00'</code> 追加时间过滤</li>
</ul>
<hr>
<h2 id="blame">blame</h2>
<blockquote>
<p>查看文件提交记录</p>
</blockquote>
<p><code>git blame file</code></p>
<hr>
<h2 id="diff">diff</h2>
<ul>
<li>默认是将 work 区 和 index 区 进行比较
<ul>
<li><code>--cached</code> stage 区 和 index 区 进行比较, 等同于 <code>--staged</code></li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;...]
</span></span><span class="line"><span class="cl">    git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;...]
</span></span><span class="line"><span class="cl">    git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;...]
</span></span><span class="line"><span class="cl">    git diff [options] &lt;blob&gt; &lt;blob&gt;
</span></span><span class="line"><span class="cl">    git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><a href="https://github.com/so-fancy/diff-so-fancy">Github:diff-so-fancy</a> <code>一个更方便查看diff的工具</code> 安装: <code>npm install -g diff-so-fancy</code></p>
</blockquote>
<hr>
<blockquote>
<p>查看当前分支和master的文件差异列表 <code>git diff master --stat=200 --compact-summary</code>， 在一个时间周期长，改动范围大的功能分支上可以在上线前快速确认下有没有漏SQL执行，漏配置项</p>
</blockquote>
<p><a href="https://git-scm.com/docs/git-diff-files/zh_HANS-CN#git-diff-files---statltgtltgtltgt">&ndash;stat 参数防止路径被折叠</a></p>
<h3 id="diff-创建-patch">diff 创建 patch</h3>
<ul>
<li>创建分支之间的patch <code>git diff branch1 branch2 &gt; first.patch</code></li>
<li>创建分支之间具体文件的patch <code>git diff branch1 branch2 path/file1 path/file2 &gt; first.patch</code>
<ul>
<li>注意文件是命令行当前路径的相对路径</li>
</ul>
</li>
<li>创建单文件的patch <code>git diff filePath &gt; first.patch</code> 路径为Git项目根路径的相对路径</li>
</ul>
<hr>
<h2 id="apply">apply</h2>
<blockquote>
<p>将patch文件应用到 index区。  Apply a patch to files and/or to the index</p>
</blockquote>
<ul>
<li><code>git apply --ignore-space-change --ignore-whitespace first.patch</code></li>
<li><code>patch -p1 &lt; first.patch</code> git apply失败可以尝试这个方式</li>
</ul>
<hr>
<h2 id="format-patch">format-patch</h2>
<blockquote>
<p>将patch文件应用为commit。 Prepare patches for e-mail submission
<a href="https://devconnected.com/how-to-create-and-apply-git-patch-files/">参考: How To Create and Apply Git Patch Files</a></p>
</blockquote>
<blockquote>
<p>创建 patch</p>
</blockquote>
<ul>
<li><code>git format-patch -1 commit-sha</code> 指定commit 创建 patch
<ul>
<li>参数选项可以为 <code>-2</code> <code>-3</code>&hellip; 数字表示 commit id 之前的 几个 commit 也创建 patch</li>
</ul>
</li>
<li><code>git format-patch master -o patches</code> 对那些 master分支 中有而当前分支没有的 commit 创建 patch 到 patches 目录</li>
<li><code>git format-patch master  --stdout &gt; total.patch</code> 将所有patch文件合并为一个</li>
</ul>
<blockquote>
<p>使用 patch</p>
</blockquote>
<p>使用<a href="#am">am</a> 或者 <a href="#apply">apply</a> 命令</p>
<hr>
<h2 id="am">am</h2>
<blockquote>
<p>Apply a series of patches from a mailbox</p>
</blockquote>
<ul>
<li>git am patches/1.patch</li>
<li>如果是单纯的搬运 commit 使用 format-patch 创建 patch 然后 使用 am 应用的方式 比 diff  然后 apply 更好， 因为会保留原有commit信息</li>
</ul>
<hr>
<h2 id="tag">tag</h2>
<blockquote>
<p><a href="https://git-scm.com/docs/git-tag/2.10.2">Official Doc</a></p>
</blockquote>
<ul>
<li>查看所有标签 <code>git tag</code>
<ul>
<li><code>-l 'v1.0.*'</code> 列出v1.0.*</li>
<li><code>git show tagname</code> 展示标签注释信息</li>
</ul>
</li>
<li>新建一个标签并打上注释 <code>git tag -a v1.0.0 -m &quot;初始版本&quot;</code>
<ul>
<li>由指定的commit打标签  <code>git tag -a v1.2.4 commit-id</code></li>
</ul>
</li>
<li>切换标签 <code>git checkout tagname</code> 和切换分支一样的，但是标签只是一个镜像，不能做提交</li>
<li>在某tag上新建一个分支 <code>git checkout -b branchname tagname</code></li>
<li>删除本地标签 <code>git tag -d tagname</code></li>
<li>删除远程的tag
<ul>
<li><code>git push origin -d tag &lt;tagname&gt;</code></li>
<li>如果本地已经删除了标签, 就可以 <code>git push origin :refs/tags/&lt;tagname&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="notes">notes</h2>
<blockquote>
<p><a href="https://git-scm.com/docs/git-notes">doc</a></p>
</blockquote>
<hr>
<h2 id="reset">reset</h2>
<blockquote>
<p>git reset -h</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">用法：git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [&lt;提交&gt;]
</span></span><span class="line"><span class="cl">  或：git reset [-q] [&lt;树或提交&gt;] [--] &lt;路径&gt;...
</span></span><span class="line"><span class="cl">  或：git reset --patch [&lt;树或提交&gt;] [--] [&lt;路径&gt;...]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    -q, --quiet           安静模式，只报告错误
</span></span><span class="line"><span class="cl">    --mixed               重置 HEAD 和索引
</span></span><span class="line"><span class="cl">    --soft                只重置 HEAD
</span></span><span class="line"><span class="cl">    --hard                重置 HEAD、索引和工作区
</span></span><span class="line"><span class="cl">    --merge               重置 HEAD、索引和工作区
</span></span><span class="line"><span class="cl">    --keep                重置 HEAD 但保存本地变更
</span></span><span class="line"><span class="cl">    --recurse-submodules[=&lt;reset&gt;]  control recursive updating of submodules
</span></span><span class="line"><span class="cl">    -p, --patch           交互式挑选数据块
</span></span><span class="line"><span class="cl">    -N, --intent-to-add   将删除的路径标记为稍后添加
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><a href="https://www.v2ex.com/t/296286">参考: 使用reset回滚代码</a></p>
</blockquote>
<h3 id="回滚add操作">回滚add操作</h3>
<ul>
<li>当执行了 git add 命令, 将文件存入暂存区</li>
<li>可以使用 <code>git reset 文件</code> 将指定文件 或者 <code>git reset .</code> 当前目录(递归) 都取消暂存</li>
<li>文件内容没有改变, 这个用于选指定文件提交时</li>
</ul>
<h3 id="回滚最近一次commit">回滚最近一次commit</h3>
<ol>
<li><code>git reset --soft HEAD^</code> 撤销最近那次 commit 行为</li>
<li>修改代码的内容</li>
<li><code>git commit -c ORIG_HEAD</code> 使用撤销的那次 commit 的注释进行提交</li>
</ol>
<blockquote>
<p>注意 reset 操作会将老的HEAD会备份到文件 .git/ORIG_HEAD 中，命令中就是引用了这个老的相关信息
-c 参数是复用指定节点的提交信息</p>
</blockquote>
<h3 id="回滚最近几次的commit并添加到一个新建的分支上去">回滚最近几次的commit并添加到一个新建的分支上去</h3>
<ol>
<li>新建分支 <code>git branch feature/new</code></li>
<li>删除master分支最近3次提交 <code>git reset --hard HEAD^3</code></li>
<li>切换到新分支上 <code>git checkout feature/new</code></li>
</ol>
<blockquote>
<p>相当于是将master上这三次的修改都转移到了这个分支上, master 从来没有过这三次提交一样
如果没有在 执行 reset &ndash;hard 之前新建分支的话, 这三次提交就永远删除了</p>
</blockquote>
<blockquote>
<p>注意: 这个操作在多人的协作中, reset &ndash;hard 比较危险, 可能引起别人分支的混乱</p>
</blockquote>
<h3 id="回滚merge和pull操作">回滚merge和pull操作</h3>
<ol>
<li>执行了merge 或者 pull 操作后</li>
<li><code>git reset --hard ORIG_HEAD</code> 注意: 该命令会将 index 和 stage 的修改清空</li>
</ol>
<h3 id="在index已有修改的状态回滚merge或者pull">在index已有修改的状态回滚merge或者pull</h3>
<ol>
<li><code>git pull</code></li>
<li><code>reset --merge ORIG_HEAD</code></li>
</ol>
<blockquote>
<p>使用 &ndash;hard 会直接回滚,直接丢失当前未提交的所有更改</p>
</blockquote>
<h3 id="被中断的工作流程">被中断的工作流程</h3>
<blockquote>
<p>在开发一个功能的时候, 突然有别的需求插进来了, 就可以通过 commit 一次, 然后回滚该次 commit 的方式
将工作状态暂存, 且不会产生垃圾提交</p>
</blockquote>
<hr>
<h2 id="gc">gc</h2>
<p><code>git gc -h</code>:</p>
<ul>
<li><code>--aggressive</code> 默认使用较快速的方式检查文档库,并完成清理,当需要比较久的时间,偶尔使用即可</li>
<li><code>--prune[=&lt;日期&gt;]</code> 清除未引用的对</li>
<li><code>--auto</code> 启用自动垃圾回收模式</li>
<li><code>--force</code> 强制执行 gc 即使另外一个 gc 正在执行</li>
</ul>
<hr>
<h2 id="clean">clean</h2>
<blockquote>
<p>Remove untracked files from the working tree <code>git clean --help</code></p>
</blockquote>
<p><code>-n</code> 参数预览删除文件列表</p>
<hr>
<h1 id="本地分支">本地分支</h1>
<blockquote>
<p>Git 的分支是轻量型的, 能够快速创建和销毁</p>
</blockquote>
<ul>
<li><code>@{-1}</code> 表示checkout的上一个分支 <a href="https://github.com/git/git/blob/master/Documentation/RelNotes/1.6.2.txt">Release V1.6.2</a>
<ul>
<li><code>git rev-parse --symbolic-full-name @{-1}</code> 展示上一个分支</li>
<li><code>git merge @{-1}</code> 将上一个分支合并进来</li>
<li><code>git branch --track mybranch @{-1}</code> 设置当前分支track上一个分支</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>获取当前分支名 <code>git symbolic-ref --short -q HEAD</code></p>
</li>
<li>
<p>拉取远程分支到本地并建立同名分支</p>
<ul>
<li>拉取元数据 <code>git fetch --all</code></li>
<li>建立和远程分支对应的本地分支 <code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="show-branch">show-branch</h2>
<blockquote>
<p>按颜色列出分支上的提交和图示</p>
</blockquote>
<p>可以查看到每次提交所属的分支</p>
<hr>
<h2 id="stash">stash</h2>
<blockquote>
<p><a href="https://git-scm.com/docs/git-stash">Official Doc</a></p>
</blockquote>
<blockquote>
<p>将当前修改缓存起来, 避免不必要的残缺提交 stash命令的缓存都是基于某个提交上的修改, 是一个栈的用法</p>
</blockquote>
<blockquote>
<p><a href="http://www.cppblog.com/deercoder/archive/2011/11/13/160007.html">参考: Git Stash的用法</a> <code>底下的评论也很有价值, 值得思考</code>
<a href="https://www.cnblogs.com/tocy/p/git-stash-reference.html">参考: git-stash用法小结</a></p>
</blockquote>
<blockquote>
<p>git stash &ndash;help 查看完整的使用说明</p>
</blockquote>
<p><code>基本动作</code></p>
<ul>
<li>push
<ul>
<li>save命令的进化版，该动作是缺省动作</li>
</ul>
</li>
<li>list
<ul>
<li>输出大致为: <code>stash@{num}: On branchName : comment</code></li>
</ul>
</li>
<li>save
<ul>
<li>save comment 已被废弃</li>
</ul>
</li>
<li>pop
<ul>
<li>将最近的stash 应用到当前仓库上, 原有的 stash 就丢弃了，如果pop缓存时发生了冲突 则不会丢弃对应的缓存</li>
</ul>
</li>
<li>apply
<ul>
<li>将指定的stash 应用到仓库上, 不丢弃原有的stash</li>
</ul>
</li>
<li>drop
<ul>
<li>丢弃指定的stash, 如果想丢弃当前项目所有更改就可以将所有更改 save stash 然后 drop</li>
</ul>
</li>
<li>clear
<ul>
<li>清除所有 stash</li>
</ul>
</li>
<li>branch
<ul>
<li>从创建缓存处创建新分支出来并pop 默认栈顶缓存，相比于pop和apply，这种方式更贴近缓存被创建时的场景</li>
</ul>
</li>
</ul>
<blockquote>
<p>push动作 实用参数</p>
</blockquote>
<ol>
<li><code>--keep-index</code> <code>-k</code> stash 将不缓存 已经被add进index区的内容</li>
<li><code>--include-untracked</code> 或 <code>-u</code> stash 将缓存未被track的文件</li>
<li><code>--patch</code> 交互式选择哪些内容需stash缓存哪些进入index区</li>
<li>如果需要恢复 <code>stash@{0}: On feature-test: test</code>
<ul>
<li>就在 feature-test 分支上建立新分支, 然后 apply stash@{0}</li>
<li>不推荐用 pop, 当stash多了以后 人不一定都记得每个stash都改了啥, 可能会有冲突以及修改覆盖的问题</li>
<li>最好用新分支装起来, 然后合并分支, 或者是 cherry-pick, 修改也不会丢失</li>
</ul>
</li>
</ol>
<blockquote>
<p><em>注意</em> stash 是一个项目范围内的栈结构, 所以如果多个分支执行了stash, 那缓存都是共用的
要先确定好当前分支 stash 的 id (通过记录comment的方式会更好) 再 pop 或者 apply (不能无脑pop 血泪教训)</p>
</blockquote>
<ul>
<li>使用该别名能展示当前分支的stash <code>alias wip='git stash list | grep $(git branch --show-current)' </code></li>
</ul>
<h3 id="stash-创建-patch">stash 创建 patch</h3>
<ul>
<li>查看stash栈某下标(提交)的差异 <code>git stash show -p stash@{0}</code>
<ul>
<li>简化别名 <code>alias gsh.st='__gshst(){ index=$1; if test -z $index; then index=0; fi; git stash show -p stash@{$index} }; __gshst'</code></li>
</ul>
</li>
<li>创建 patch <code>gsh.st &gt; dev.patch</code></li>
</ul>
<h3 id="恢复被drop的stash">恢复被drop的stash</h3>
<blockquote>
<p><a href="https://stackoverflow.com/questions/89332/how-to-recover-a-dropped-stash-in-git">How to recover a dropped stash in Git?</a></p>
</blockquote>
<p>可以恢复 stash drop 或者 clean 的内容。stash drop后会输出 <code>Dropped refs/stash@{0} (......)</code>， 括号内就是该次stash对应的commitId</p>
<ul>
<li><code>git fsck --no-reflog | awk '/dangling commit/ {print $3}'</code>
<ul>
<li>使用 gitk 显示 <code>gitk --all $(git fsck --no-reflog | awk '/dangling commit/ {print $3}')</code></li>
<li>或者在命令后接管道 <code> | xargs git show</code>, 查找代码内容</li>
</ul>
</li>
<li>WIP 开头的就是 stash 对应的 commit , 找到对应的 sha1 id 建立新分支即可
<ul>
<li>也就是说 stash 仍然是采用 分支 来实现的, 在某个分支stash 就相当于在该分支进行 commit</li>
</ul>
</li>
</ul>
<hr>
<h2 id="branch">branch</h2>
<blockquote>
<p>查看所有参数 <code>git branch --help</code></p>
</blockquote>
<ul>
<li>列出所有分支(包含本地和远程) <code>-a --all</code></li>
<li>按条件显示分支 <code>--list 'feature*'</code></li>
<li>列出远程分支 <code>-r --remote</code></li>
<li>查看分支详细信息 <code>-vv</code> 本地分支和远程分支的关联状态</li>
<li>查看包含指定 commit(可以多个) 的分支 <code>--contains [&lt;commit&gt;]</code>
<ul>
<li>对应的则是不包含 <code>--no-contains [&lt;commit&gt;]</code> commit 缺省为 HEAD(也就是最近的一次提交)</li>
</ul>
</li>
<li>创建分支 <code>git branch name</code> 并设置当前分支的对应远程分支 <code>-t &lt;remote&gt;/&lt;branch&gt;</code></li>
<li>重命名分支 <code>-m old new</code> 对于远程来说就是先要删除再新建分支</li>
<li>删除分支 <code>-d 分支</code>
<ul>
<li>如果该分支没有被完全合并, 就会提醒使用 <code>-D</code> 强制删除. 等价于 <code>--delete --force</code></li>
</ul>
</li>
<li>设置当前分支跟踪的远程分支 <code>--set-upstream-to=&lt;remote&gt;/&lt;branch&gt; &lt;branch&gt;</code></li>
<li>查看当前分支合并/未合并的其他分支 <code>--merged</code> <code>--no-merged</code></li>
</ul>
<hr>
<h2 id="checkout">checkout</h2>
<blockquote>
<p><a href="https://git-scm.com/docs/git-checkout">Official Doc: git checkout</a></p>
</blockquote>
<ol>
<li>切换分支 <code>git checkout feature/a</code></li>
<li>切换至上一个分支 <code>git checkout -</code> 等价于 <code>git checkout @{-1}</code></li>
<li>切换分支并设置该分支的远程分支 <code>gh feature/a origin/feature/a</code></li>
</ol>
<blockquote>
<p>撤销文件修改</p>
</blockquote>
<ul>
<li>
<p><code>git checkout .</code> 取出最近的一次提交, 覆盖掉 work 区下当前目录(递归)下所有已更改(包括删除操作), 且未进入 stage 的内容, 已经进入 stage 区的文件内容则不受影响</p>
<ul>
<li><code>git checkout 文件1 文件2...</code> 同上, 但是只操作指定的文件</li>
</ul>
</li>
<li>
<p><code>git checkout [commit-hash] 文件1 文件2...</code> 根据指定的 commit 对应hash值, 作如上操作, 但是区别在于 从 index 直接覆盖掉 stage 区, 并丢弃 work 区</p>
<ul>
<li><code>git checkout [commit-hash] .</code></li>
<li><strong><code>如在项目根目录执行该命令, 会将当前项目的所有未提交修改全部丢失, 不可恢复!!!!</code></strong>, 所以应尽量使用 stash 命令，即使pop也能恢复</li>
</ul>
</li>
<li>
<p><code>git checkout [commit-hash] 节点标识符或者标签 文件名 文件名 ...</code></p>
<ul>
<li>取出指定节点状态的某文件，而且执行完命令后，取出的那个状态会成为head状态，</li>
<li>需要执行  <code>git reset HEAD</code> 来清除这种状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>实验性命令： git switch branch</p>
</blockquote>
<h2 id="分支合并">分支合并</h2>
<blockquote>
<p>merge rebase squash 三种合并策略</p>
</blockquote>
<ul>
<li>Merge会创建合并节点形成环</li>
<li>Rebase是通过调整两个分支链上的提交，合并成一个链没有环</li>
<li>Squash不是具体命令，做法是将需要合并过去的那些提交撤销得到文件修改，基于这些修改再创建一个新提交。好处是分支图上只有主要合并提交，没有中间提交信息的干扰</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/192972614">这才是真正的 Git——分支合并</a></p>
<p>Git 在合并分支的时候使用的是 三向合并策略，即当前分支和目标分支的共同祖先commit节点， 和两个分支的当前commmit节点进行比较确定哪一方发生修改需要纳入，如果两方都修改就要提示冲突</p>
<p>根据 Git 的合并策略，在合并两个有分叉的分支（上图中的 D、E‘）时，Git 默认会选择 Recursive 策略。找到 D 和 E’的最短路径共同祖先节点 B，以 B 为 base，对 D，E‘做三向合并。</p>
<p>B 中有 http.js，D 中有 http.js 和 main.js，E’中什么都没有。根据三向合并，B、D 中都有 http.js 且没有变更，E‘删除了 http.js，所以合并结果就是没有 http.js，没有冲突，所以 http.js 最终会被删除。</p>
<h3 id="分支问题排查">分支问题排查</h3>
<ul>
<li><code>git merge-base 分支1 分支2</code> 查看两个分支共同祖先（前提:两个分支通过merge命令发生的合并，如果是rebase则找不到真正的祖先节点）</li>
<li><code>git show-branch 分支1 分支2 分支3</code> 查看若干分支差异提交情况</li>
</ul>
<h2 id="merge">merge</h2>
<ul>
<li><a href="https://git-scm.com/docs/git-merge">官方文档</a></li>
</ul>
<blockquote>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6">Official Doc: 高级合并</a>
<a href="https://www.jianshu.com/p/58a166f24c81">参考: git-merge完全解析</a></p>
</blockquote>
<ul>
<li><code>git merge develop</code> 默认 是 ff(fast forward) 不生成新节点，直接将当前分支指向Develop分支。(一条拐弯的分支线)
<ul>
<li>推荐: <code>git merge --no-ff develop</code> 在当前分支 <code>主动合并</code>分支Develop，生成一个新节点，分支图的合并路径清晰</li>
</ul>
</li>
<li><code>--squash</code> 和 <code>--no-squash</code> 该参数和 <code>--no-ff</code> 冲突
<ul>
<li>使用 <code>--squash</code> 时，当一个合并发生时，从当前分支和对方分支的共同祖先节点，一直到对方分支的顶部节点内的所有提交内容将修改当前工作区，使用者可以经过审视后进行提交，产生一个新的节点。</li>
<li>这种情况下分支图看不到合并的环，只会看作一个简单的提交</li>
</ul>
</li>
<li>如果遇到冲突：
<ul>
<li><code>git mergetool</code> 使用工具进行分析冲突文件方便修改</li>
</ul>
</li>
</ul>
<blockquote>
<p>配置mergetool工具kdiff3, 同类的还有meld：</p>
</blockquote>
<ul>
<li><code>git config --global merge.tool kdiff3</code></li>
<li><code>git config --global mergetool.kdiff3.cmd &quot;'D:/kdiff3.exe' \&quot;\$BASE\&quot; \&quot;\$LOCAL\&quot; \&quot;\$REMOTE\&quot; -o \&quot;\$MERGED\&quot;&quot;</code></li>
<li><code>git config --global mergetool.prompt false</code></li>
<li><code>git config --global mergetool.kdiff3.trustExitCode true</code></li>
<li><code>git config --global mergetool.keepBackup false</code></li>
</ul>
<blockquote>
<p><a href="https://git-scm.com/docs/merge-strategies">merge 策略</a></p>
</blockquote>
<ul>
<li>Git 2.34 新增 ort 策略</li>
</ul>
<hr>
<h2 id="rebase">rebase</h2>
<blockquote>
<p><a href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing">Official Doc</a></p>
</blockquote>
<blockquote>
<p>衍和操作 <a href="http://blog.csdn.net/endlu/article/details/51605861">参考博客</a> |
<a href="http://blog.csdn.net/zwlove5280/article/details/46649799">Git rebase -i 交互变基</a> |
<a href="http://blog.csdn.net/zwlove5280/article/details/46708969">git rebase的原理之多人合作分支管理</a>
这种合并方式，不会像merge方式那样在分支图上出现多个圈，而是线性演进, 但是遇到冲突后会改动历史提交，导致提交不是按时间演进，不利于分布式协作</p>
</blockquote>
<ul>
<li>与master合并：<code>git merge master</code> 换成 <code>git rebase master</code></li>
<li>当遇到冲突：
<ul>
<li><code>git rebase --abort</code> 放弃rebase</li>
<li><code>git rebase --continue</code> 修改好冲突后继续</li>
</ul>
</li>
</ul>
<blockquote>
<p>master 提交了 b,c
dev 提交了 d,e</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">merge master: 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">master: a - b - c 
</span></span><span class="line"><span class="cl">             \   \
</span></span><span class="line"><span class="cl">dev:          d - e
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">rebase master: 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">master: a - b - c - d&#39; - e&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>merge 会保留分支图, rebase 会保持提交记录为单分支</p>
<hr>
<h2 id="cherry-pick">cherry-pick</h2>
<blockquote>
<p><a href="https://git-scm.com/docs/git-cherry-pick">Official Doc</a></p>
</blockquote>
<ul>
<li><code>git cherry-pick &lt;commit-id&gt;</code></li>
</ul>
<p>简单来讲, 就是将指定的某个提交(任意分支上的)上的修改, 重放到当前分支上 和 stash pop 命令相比, 在重放上是一致的， 使修改内容生效，commitId会变化</p>
<blockquote>
<p>用途</p>
</blockquote>
<ol>
<li>可用于合并已有的若干个提交, 为了改动最小, 一般新建分支来做这件事
<ul>
<li>例如 功能分支 <code>fea/something</code> 上的四个提交其实可以合并, 使得提交信息更清晰, 不冗余, 就可以从 <code>fea/something</code></li>
<li>创建处新建一个分支, 将该分支所有提交进行重放, 需要合并的那几个放一起重放 然后 将四个提交 reset, 再次提交即可</li>
</ul>
</li>
</ol>
<h2 id="bisect">bisect</h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">git bisect 命令教程</a></li>
<li><a href="http://www.worldhello.net/2016/02/29/git-bisect-on-git.html">二分查找捉虫记</a> <code>通过分析提交历史查到哪次提交引起的Bug然后检出,修复</code></li>
</ul>
<h2 id="worktree">worktree</h2>
<blockquote>
<p>Manage multiple working trees <a href="https://git-scm.com/docs/git-worktree">doc</a></p>
</blockquote>
<hr>
<h1 id="远程操作">远程操作</h1>
<blockquote>
<p>Git大部分命令都是本地的, 所以执行效率很高, 但是协同开发必须有同步的操作</p>
</blockquote>
<p>其实单独的两个主机也能完成同步, 两个主机之间 使用同一个仓库进行开发
两个人互为对方的远程库(使用 git daemon 即可搭建简易服务端), 添加为 remote 即可操作</p>
<p>指定本地开发分支和远程的绑定关系 <code>git branch --set-upstream dev origin/dev</code> 而且 一个本地库是能够绑定多个远程的</p>
<blockquote>
<p>Github上fork的项目</p>
</blockquote>
<p><strong>合并对方最新代码</strong></p>
<ol>
<li>首先fork一个项目, 然后clone自己所属的该项目下来,假设 原作者为A 自己为B</li>
<li>添加原作者项目的URL 到该项目的远程分支列表中 <code>git add remote A A_URL</code></li>
<li>fetch作者的代码到本地 <code>git fetch A</code></li>
<li>在B分支上合并作者分支代码 <code>git merge --no-ff A/master</code></li>
<li>push即可</li>
</ol>
<blockquote>
<p>Github上PR</p>
</blockquote>
<p><a href="https://github.com/mockito/mockito/wiki/Using-git-to-prepare-your-PR-to-have-a-clean-history">Using git to prepare your PR to have a clean history</a></p>
<hr>
<h2 id="remote">remote</h2>
<blockquote>
<p><a href="https://git-scm.com/docs/git-remote">Official Doc</a></p>
</blockquote>
<ol>
<li><strong>常用参数</strong>
<ul>
<li><code>add name URL地址</code> 添加远程关联仓库 不唯一，可以关联多个, 一般默认是origin</li>
<li><code>set-url name URL地址</code> 修改关联仓库的URL</li>
<li><code>rm URL</code> 删除和远程文档库的关系</li>
<li><code>rename origin myth</code> 更改远程文档库的名称</li>
<li><code>show origin</code> 查看远程分支的状态和信息</li>
</ul>
</li>
<li>显示本地仓库跟踪的那个远程仓库 <code>git ls-remote</code></li>
<li>查看关联远程仓库的详情(push和pull的地址) <code>git remote -v</code></li>
</ol>
<ul>
<li><a href="http://zengrong.net/post/1746.htm">参考: 删除，重命名远程分支</a></li>
</ul>
<hr>
<h2 id="push">push</h2>
<ul>
<li>
<p><em>常用参数</em></p>
<ul>
<li><code>-q</code> 控制台不输出任何信息</li>
<li><code>-f</code> 强制推送提交 <strong>使用这个参数时要再三考虑清楚</strong></li>
<li><code>--all</code> 推送所有分支</li>
<li><code>-u</code> upstream 设置 git pull/status 的上游
<ul>
<li><code>git push origin master</code>和 <code>git push -u origin master</code> 区别在于 前者是使用该远程和分支进行推送</li>
<li>后者也是推送, 并设置origin为默认推送的远程, 以后push就不用注明远程名了(多远程的情况下要注意)</li>
</ul>
</li>
<li><code>-d --delete</code> 删除引用(分支或标签)</li>
</ul>
</li>
<li>
<p>删除远程分支</p>
<ul>
<li><code>git push origin -d 分支名称</code></li>
<li>如果本地已经删除了该分支，就可以 <code>git push origin :分支名称</code></li>
</ul>
</li>
<li>
<p>第一次将本地分支与远程建立关系</p>
<ul>
<li><code>git push -u origin master </code> | <code>git push --set-uptream master</code> | <code>git push -all</code> (会将所有分支一起push)</li>
</ul>
</li>
<li>
<p>提交指定tag <code>git push origin tagname</code></p>
<ul>
<li>提交所有tag <code>git push --tags</code></li>
</ul>
</li>
<li>
<p>出现 <code>RPC failed; result=22, HTTP code = 411</code> 的错误</p>
<ul>
<li>就是因为一次提交的文件太大，需要改大缓冲区 例如改成500m  <code>git config http.postBuffer 524288000</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="fetch">fetch</h2>
<blockquote>
<p>访问远程仓库, 拉取本地没有的远程数据</p>
</blockquote>
<ul>
<li>注意 fetch 是一个分支一个分支进行拉取的, 在此基础上可以优化网络不稳定时clone代码的问题
<ul>
<li>关键是分支之间独立拉取不会像clone拉取所有分支，有分支拉取失败就要从头再来</li>
<li>操作过程: 创建空目录并进入， <code>git init</code> 然后 <code>git fetch URL</code></li>
<li>创建 msater分支 <code>git checkout -b master FETCH_HEAD</code></li>
<li>拉取其他分支 <code>git fetch --all</code></li>
</ul>
</li>
<li>拉取本地没有的分支（两种方式）
<ol>
<li><strong>推荐</strong> 拉取 origin 信息 <code>git fetch --all</code> 由远程分支创建新分支并设定跟踪 <code>git checkout -b dev origin/dev</code></li>
<li>拉取 origin 的 dev 分支 并在本地创建 dev 分支 <code>git fetch origin dev:dev</code>
<ul>
<li>但此时本地的分支并没有 track 远程分支，需要执行 <code>git push -u origin dev</code> 进行设置</li>
</ul>
</li>
</ol>
</li>
<li>删除远程没有但本地有的那些分支 <code>git fetch -p</code></li>
<li><code>git fetch origin dev-test</code> 下拉指定远程的指定分支 至 origin/dev-test 但不会创建本地分支</li>
</ul>
<blockquote>
<p>fetch 不到所有远程分支的原因和解决方案</p>
</blockquote>
<ul>
<li>查看fetch的源 <code>git config --get remote.origin.fetch</code></li>
<li>需要配置为通配方式 <code>git config --add remote.origin.fetch &quot;+refs/heads/*:refs/remotes/origin/*&quot;</code></li>
</ul>
<hr>
<h2 id="pull">pull</h2>
<blockquote>
<p>不仅仅是 fetch 代码, 还会进行 merge 操作, 所以安全起见, 是先 fetch 然后再手动 merge</p>
</blockquote>
<ul>
<li><code>git pull origin dev</code> 下拉指定远程的指定分支</li>
<li><code>git pull --all</code> 下拉默认远程的所有分支代码并自动合并</li>
<li>拉取项目所有远程分支到本地</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">    git branch -r <span class="p">|</span> grep -v <span class="s1">&#39;\-&gt;&#39;</span> <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> remote<span class="p">;</span> <span class="k">do</span> git branch --track <span class="s2">&#34;</span><span class="si">${</span><span class="nv">remote</span><span class="p">#origin/</span><span class="si">}</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="nv">$remote</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span>
</span></span><span class="line"><span class="cl">    git fetch --all
</span></span><span class="line"><span class="cl">    git pull --all
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>git pull 默认策略配置</p>
</blockquote>
<ul>
<li>git config pull.rebase false  # merge</li>
<li>git config pull.rebase true   # rebase</li>
<li>git config pull.ff only       # fast-forward only</li>
</ul>
<blockquote>
<p>error: cannot lock ref &lsquo;refs/remotes/origin/test/v1.0.0&rsquo; : &lsquo;refs/remotes/origin/test&rsquo; exists;</p>
</blockquote>
<p>原因： 由于git的分支都是以目录和文件形式存储，分支名包含 / 时会创建对应的目录, 因此无法同时创建 test 分支和 test/v1.0.0 分支，目录test和文件test冲突了</p>
<p>需要手动删除test分支，或者重命名test/v1.0.0 为 test_v1.0.0 .</p>
<p>上诉错误容易出现在Clone多份仓库时，某份仓库删了test分支并push， 但是这份仓库的 remote 引用管理未清理</p>
<p>清理远程引用:  <code>git update-ref -d refs/remotes/origin/test</code></p>
<hr>
<h1 id="submodule">Submodule</h1>
<blockquote>
<p><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">Official Doc</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/wangjia55/article/details/24400501">git submodule的使用</a>
<a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html">参考: Git Submodule使用完整教程</a></p>
</blockquote>
<ul>
<li>能够在一个git仓库中将一个文件夹作为一些独立的子仓库进行管理</li>
<li>添加子模块 <code>git submodule add url dir</code> 目录为可选项</li>
</ul>
<p>当主仓库 clone 时 只会将子模块作为空目录克隆下来</p>
<ul>
<li>读取 .gitmodules 文件完成子模块的注册 <code>git submodule init</code></li>
<li>拉取子模块代码 <code>git submodule update</code></li>
</ul>
<p>以上两条命令等价于 <code>git submodule update --init --recursive</code></p>
<p><code>删除子模块</code></p>
<ol>
<li>删除.gitsubmodule里相关部分</li>
<li>删除.git/config 文件里相关字段</li>
<li>删除子仓库目录</li>
</ol>
<hr>
<h1 id="其他">其他</h1>
<h2 id="gitk">gitk</h2>
<blockquote>
<p>图形化展示分支 需要依赖 tcl tk</p>
</blockquote>
<h2 id="grep">grep</h2>
<ul>
<li>搜索文字 <code>git grep docker</code>
<ul>
<li><code>-n</code>搜索并显示行号</li>
<li><code>--name-only</code> 只显示文件名，不显示内容</li>
<li><code>-c</code> 查看每个文件里有多少行匹配内容(line matches):</li>
<li>查找git仓库里某个特定版本里的内容, 在命令行末尾加上标签名(tag reference):  <code>git grep xmmap v1.5.0</code></li>
<li><code>git grep --all-match -e '#define' -e SORT_DIRENT</code> 匹配两个字符串</li>
</ul>
</li>
</ul>
<h2 id="archive">archive</h2>
<ol>
<li>将某版本打包成压缩包 <code>git archive -v --format=zip v0.1 &gt; v0.1.zip</code></li>
</ol>
<h2 id="reflog">reflog</h2>
<ul>
<li>查看仓库的本地操作日志 仅记录HEAD以及所有分支引用所指向的历史</li>
</ul>
<ol>
<li><code>git reflog</code> 显示commit操作详情，仅本地保存</li>
</ol>
<h2 id="rev-parse">rev-parse</h2>
<blockquote>
<p>该工具是Git内部命令 往往被其他子命令使用</p>
</blockquote>
<ol>
<li>查看分支指向具体的commit id <code>git rev-parse fea/new</code></li>
<li>查看上一个分支 <code>git rev-parse --symbolic-full-name @{-1}</code></li>
</ol>
<h2 id="scalar">scalar</h2>
<blockquote>
<p><a href="https://git-scm.com/docs/scalar">Git scalar</a> 自2.42.1起支持，原理为先稀疏检出，然后定时任务拉取变更</p>
</blockquote>
<h2 id="githooks">githooks</h2>
<p>实现机制： 一组在<code>.git/hook/</code>目录下的shell，在git完成特定行为后会触发执行对应的脚本</p>
<ul>
<li>pre-commit：在执行提交操作之前触发。这是一个非常有用的钩子，可以用来进行代码风格检查、静态代码分析、运行测试等操作，确保提交的代码质量。</li>
<li>pre-push：在执行推送操作之前触发。在这个钩子中，我们可以运行更严格的测试，如集成测试、端到端测试等，以确保准备推送的代码符合质量标准。</li>
<li>post-commit：在执行提交操作后触发。该钩子可以用于执行一些后续操作，如自动构建、生成文档等。</li>
<li>post-checkout：在执行检出操作后触发。这个钩子适用于更新依赖、重置配置等与项目状态相关的任务。</li>
<li>post-merge：在执行合并操作后触发。我们可以在该钩子中执行一些与合并后操作相关的任务。</li>
</ul>
<blockquote>
<p>注意hook脚本不会被git纳入版本管理，所以需要手动维护<br>
注意脚本执行的工作目录是仓库根目录</p>
</blockquote>
<blockquote>
<p><a href="https://pre-commit.com/">pre-commit</a></p>
</blockquote>
<hr>
<h1 id="配置文件">配置文件</h1>
<h2 id="gitignore">gitignore</h2>
<blockquote>
<p><a href="https://github.com/github/gitignore">Github: gitignore</a> | 一行则是一个配置，且可以仓库和目录存在不同的配置，git会按就近原则匹配</p>
</blockquote>
<ul>
<li>使用 <code>#</code> 注释一行</li>
<li><code>test.txt</code>  忽略该文件</li>
<li><code>*.html</code>  忽略所有HTML后缀文件</li>
<li><code>*[o/a]</code>  忽略所有o和a后缀的文件</li>
<li><code>!foo.html</code>  不忽略该文件</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    */ #忽略所有文件
</span></span><span class="line"><span class="cl">    build/ #所有build目录
</span></span><span class="line"><span class="cl">    /build #只忽略当前目录的build, 子目录的不忽略
</span></span><span class="line"><span class="cl">    *.iml #所有iml文件
</span></span><span class="line"><span class="cl">    ?.log #忽略所有 后缀为log, 文件名字只有一个字母
</span></span><span class="line"><span class="cl">    !*.java #不忽略所有java文件
</span></span><span class="line"><span class="cl">    a.[abc] #忽略 后缀为 a或者b或者c 的文件
</span></span><span class="line"><span class="cl">    doc/*.txt #忽略 doc一级子目录的txt文件, 不忽略多级子目录中txt
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="gitattributes">gitattributes</h2>
<blockquote>
<p><a href="http://schacon.github.io/git/gitattributes.html">gitattributes</a></p>
</blockquote>
<ol>
<li>配置文件的换行符 eol</li>
<li>working-tree-encoding</li>
<li>ident</li>
<li>filter</li>
<li>merge</li>
<li>whitespace</li>
<li>export-ignore</li>
<li>delta</li>
<li>encoding</li>
</ol>
<hr>
<h1 id="自定义插件">自定义插件</h1>
<blockquote>
<p><a href="https://adamcod.es/2013/07/12/how-to-create-git-plugin.html">how-to-create-git-plugin</a></p>
</blockquote>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Kuangcp</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2024-01-04
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/distributed/configcenter/nacos/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Nacos</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/java/android/androidbase/">
            <span class="next-text nav-default">Android基础</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/Kuangcp" class="iconfont icon-github" title="github"></a>
  <a href="https://www.kuangcp.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://gitee.com/gin9/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2016 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span>
    <span>Kuangcp</span>
    
    <br/><span><a href='http://beian.miit.gov.cn/'; target=_blank>赣ICP备17014189号</a></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>








</body>
</html>
