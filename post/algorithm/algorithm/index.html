<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>数据结构和算法 - Mythos</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Mythos" /><meta name="description" content="目录 start 数据结构和算法 相关书籍和资源 基础概念 算法的重要特征 时间复杂度 时间复杂度分析 最好最坏时间复杂度 平均时间复杂度 均摊时间复杂度 空间复杂度 基础" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.93.2 with theme even" />


<link rel="canonical" href="https://blogs.kuangcp.top/post/algorithm/algorithm/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.154ed883776547b0e136be39b3037f61350da06f888d0868d1756a9463cd9520.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="数据结构和算法" />
<meta property="og:description" content="目录 start 数据结构和算法 相关书籍和资源 基础概念 算法的重要特征 时间复杂度 时间复杂度分析 最好最坏时间复杂度 平均时间复杂度 均摊时间复杂度 空间复杂度 基础" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blogs.kuangcp.top/post/algorithm/algorithm/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-21T10:56:52+00:00" />
<meta property="article:modified_time" content="2018-11-21T10:56:52+00:00" />

<meta itemprop="name" content="数据结构和算法">
<meta itemprop="description" content="目录 start 数据结构和算法 相关书籍和资源 基础概念 算法的重要特征 时间复杂度 时间复杂度分析 最好最坏时间复杂度 平均时间复杂度 均摊时间复杂度 空间复杂度 基础"><meta itemprop="datePublished" content="2018-11-21T10:56:52+00:00" />
<meta itemprop="dateModified" content="2018-11-21T10:56:52+00:00" />
<meta itemprop="wordCount" content="7227">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据结构和算法"/>
<meta name="twitter:description" content="目录 start 数据结构和算法 相关书籍和资源 基础概念 算法的重要特征 时间复杂度 时间复杂度分析 最好最坏时间复杂度 平均时间复杂度 均摊时间复杂度 空间复杂度 基础"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Mythos</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Mythos</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">数据结构和算法</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-11-21 </span>
        <div class="post-category">
            <a href="/categories/%E7%AE%97%E6%B3%95/"> 算法 </a>
            </div>
          <span class="more-meta"> 7227 words </span>
          <span class="more-meta"> 15 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#相关书籍和资源">相关书籍和资源</a></li>
    <li><a href="#基础概念">基础概念</a>
      <ul>
        <li><a href="#算法的重要特征">算法的重要特征</a></li>
        <li><a href="#时间复杂度">时间复杂度</a></li>
        <li><a href="#空间复杂度">空间复杂度</a></li>
      </ul>
    </li>
    <li><a href="#基础数据结构">基础数据结构</a>
      <ul>
        <li><a href="#线性表">线性表</a></li>
        <li><a href="#树">树</a></li>
      </ul>
    </li>
    <li><a href="#匹配算法">匹配算法</a></li>
    <li><a href="#排序算法">排序算法</a></li>
    <li><a href="#搜索算法">搜索算法</a></li>
    <li><a href="#哈希算法">哈希算法</a>
      <ul>
        <li><a href="#hash函数构造">HASH函数构造</a></li>
        <li><a href="#hash-冲突">HASH 冲突</a></li>
        <li><a href="#安全相关">安全相关</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#diffie-hellman-key-exchange算法">Diffie-Hellman Key Exchange算法</a></li>
  </ul>

  <ul>
    <li><a href="#斐波那契数列">斐波那契数列</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><strong>目录 start</strong></p>
<ol>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95">数据结构和算法</a>
<ol>
<li><a href="#%E7%9B%B8%E5%85%B3%E4%B9%A6%E7%B1%8D%E5%92%8C%E8%B5%84%E6%BA%90">相关书籍和资源</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">基础概念</a>
<ol>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E5%BE%81">算法的重要特征</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a>
<ol>
<li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">时间复杂度分析</a></li>
<li><a href="#%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">最好最坏时间复杂度</a></li>
<li><a href="#%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">平均时间复杂度</a></li>
<li><a href="#%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">均摊时间复杂度</a></li>
</ol>
</li>
<li><a href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">空间复杂度</a></li>
</ol>
</li>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">基础数据结构</a>
<ol>
<li><a href="#%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表</a>
<ol>
<li><a href="#%E6%95%B0%E7%BB%84">数组</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8">链表</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%AF%B9%E6%AF%94">数组和链表对比</a></li>
</ol>
</li>
<li><a href="#%E6%A0%91">树</a></li>
</ol>
</li>
<li><a href="#%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">匹配算法</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a></li>
<li><a href="#%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">搜索算法</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95">哈希算法</a>
<ol>
<li><a href="#hash%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0">HASH函数构造</a></li>
<li><a href="#hash-%E5%86%B2%E7%AA%81">HASH 冲突</a>
<ol>
<li><a href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95">开放定址法</a></li>
<li><a href="#%E5%86%8D-hash-%E6%B3%95">再 HASH 法</a></li>
<li><a href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%8B%89%E9%93%BE-%E6%B3%95">链地址/拉链 法</a></li>
<li><a href="#%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA">公共溢出区</a></li>
</ol>
</li>
<li><a href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3">安全相关</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#%E5%AF%86%E7%A0%81%E5%AD%A6">密码学</a>
<ol>
<li><a href="#diffie-hellman-key-exchange%E7%AE%97%E6%B3%95">Diffie-Hellman Key Exchange算法</a></li>
</ol>
</li>
<li><a href="#%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98">实际问题</a>
<ol>
<li><a href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波那契数列</a></li>
</ol>
</li>
</ol>
<p><strong>目录 end</strong>|<em>2020-11-16 12:11</em>|</p>
<hr>
<h1 id="数据结构和算法">数据结构和算法</h1>
<blockquote>
<p>数据结构是指一组数据的存储结构 算法就是操作数据的方法 数据结构和算法是相辅相成的，数据结构是为算法服务的，而算法要作用在特定的数据结构之上</p>
</blockquote>
<blockquote>
<p><a href="https://gitee.com/gin9/MindMap">相关思维导图</a></p>
</blockquote>
<h2 id="相关书籍和资源">相关书籍和资源</h2>
<ul>
<li>
<p>大话数据结构</p>
</li>
<li>
<p>算法图解 <a href="https://github.com/egonSchiele/grokking_algorithms">Github</a></p>
</li>
<li>
<p>算法的乐趣</p>
</li>
<li>
<p>算法 <a href="https://algs4.cs.princeton.edu/home/">official site</a></p>
</li>
<li>
<p>算法导论(英文原版更好) 麻省理工有公开课</p>
</li>
<li>
<p>数据结构与算法分析 C C++ Java 三种语言版本</p>
</li>
<li>
<p>数据结构 严蔚敏</p>
</li>
<li>
<p>数据结构与算法解析  高一凡</p>
</li>
<li>
<p>剑指Offer</p>
</li>
<li>
<p>编程珠玑 对大量数据问题的算法研究</p>
</li>
<li>
<p>编程之美 微软面试官所著,难度较高</p>
</li>
<li>
<p>计算机程序设计艺术</p>
</li>
<li>
<p>算法帝国</p>
</li>
<li>
<p>数学之美</p>
</li>
<li>
<p>算法之美</p>
</li>
</ul>
<blockquote>
<p><a href="https://github.com/wangzheng0822/algo">王争的课程对应源码</a><code>这里主要也是他的课程内容</code>
<a href="https://github.com/TheAlgorithms">Github:TheAlgorithms</a> <code>有各种编程语言的算法实现</code>
<a href="https://github.com/julycoding/The-Art-Of-Programming-By-July">《编程之法》</a></p>
</blockquote>
<blockquote>
<p><a href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/index.htm">清华大学 邓俊辉 数据结构 C++实现</a></p>
</blockquote>
<blockquote>
<p><a href="http://www-bcf.usc.edu/~dkempe/teaching/DataStructures.pdf">DataStructures.pdf</a>
<a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.pdf">notes.pdf</a>
<a href="http://web.stanford.edu/class/archive/cs/cs103/cs103.1164/notes/">notes</a>
<a href="https://inst.eecs.berkeley.edu/~cs61b/fa18/materials/book2/data-structures.pdf">data structures.pdf</a>
<a href="https://www.cs.auckland.ac.nz/textbookCS220/ebook/DGW2.pdf">Data structure.pdf</a>
<a href="http://jeffe.cs.illinois.edu/teaching/algorithms/">algorithms</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/TheAlgorithms/Java">TheAlgorithms-Java </a>
<a href="https://github.com/wangzheng0822/algo">数据结构和算法必知必会的50个代码实现</a></p>
</blockquote>
<hr>
<p>离散数学基础: 集合、偏序集、良序、数学归纳法、级数、递归、递推
概率基础: 随机分布、概率、伯努利实验、数学期望、期望值的线性率</p>
<ul>
<li>常用数据结构:
<ul>
<li>数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树</li>
</ul>
</li>
<li>常用算法
<ul>
<li>递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="基础概念">基础概念</h2>
<h3 id="算法的重要特征">算法的重要特征</h3>
<ol>
<li>有穷性：保证执行有限步骤之后结束</li>
<li>确切性：每一步骤都有确切的定义</li>
<li>输入：每个算法有一个或多个输入，以刻画运算对象的初始情况。所谓零个输入是指算法本身舍弃了初始条件</li>
<li>输出：每个算法有一个或多个输出，显示对应输入数据加工后的结果。没有输出的算法是毫无意义的</li>
<li>可行性：在原则上算法能够精确地运行，进行有限次运算即可完成一次运算</li>
</ol>
<h3 id="时间复杂度">时间复杂度</h3>
<blockquote>
<p><a href="http://www.baeldung.com/java-algorithm-complexity">Java中的实践</a></p>
</blockquote>
<p>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。</p>
<ul>
<li>T(n) = O(f(n))
<ul>
<li>T(n) 表示代码执行的时间；</li>
<li>n 表示数据规模的大小；</li>
<li>f(n) 表示每行代码执行的次数总和。</li>
</ul>
</li>
</ul>
<p>因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度(asymptotic time complexity) 简称时间复杂度</p>
<h4 id="时间复杂度分析">时间复杂度分析</h4>
<ol>
<li>只关注循环执行次数最多的代码</li>
<li>加法原则: 相加时的结果是: 总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法原则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
<ul>
<li>常见的时间复杂度
<ul>
<li>常量阶 O(1)</li>
<li>对数阶 O(log n)</li>
<li>线性阶 O(n)</li>
<li>线性对数阶 O(n log n)</li>
<li>平方阶 O(n^2) 立方阶O(n^3 )  k次方阶 O(n^k) <code>用 ^ 表示次方</code></li>
<li>指数阶 O(2^n)</li>
<li>阶乘阶 O(n!)</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>O(1)</p>
</blockquote>
<p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</p>
<hr>
<blockquote>
<p>O(logn)、O(nlogn)</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对数之间是可以互相转换的，log3 n 就等于 <code>log3 2 * log2 n</code>，所以 <code>O(log3 n) = O(C * log2 n)</code>，其中 C=log3 2 是一个常量。<br>
基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))<br>
所以，O(log2 n) 就等于 O(log3 n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p>
<p>O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
<ul>
<li>个人看法: 当循环中的循环变量的增长是以指数形式增长, 从而达到循环退出条件, 那么时间复杂度就是对数形式的</li>
</ul>
<hr>
<blockquote>
<p>O(m+n)、O(m*n)</p>
</blockquote>
<p>时间复杂度由两个数据的规模来决定, 原来的加法法则需要改为 T1(m) + T2(n) = O(f(m) + g(n)), 不清楚 m n 大小关系, 所以只能同时评估</p>
<p>四个复杂度分析方面的知识点，最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均情况时间复杂度（average case time complexity）、均摊时间复杂度（amortized time complexity）。</p>
<p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度，最坏情况时间复杂度和平均情况时间复杂度</p>
<h4 id="最好最坏时间复杂度">最好最坏时间复杂度</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="c1">// n 表示数组 array 的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>顾名思义，最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量x正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度 O(1)。<br>
同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度 O(n)。</p>
<h4 id="平均时间复杂度">平均时间复杂度</h4>
<p>要查找的变量 x 在数组中的位置，有 n+1 种情况：<code>在数组的 0～n-1 位置中和不在数组中</code>。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值</p>
<blockquote>
<p>(1+2+3+&hellip;+n+n) / (n+1) = n(n+3) / 2(n+1)</p>
</blockquote>
<p>时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p>
<p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便, 假设在数组中与不在数组中的概率都为 1/2。<br>
另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。<br>
所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。<br>
因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p>
<blockquote>
<p>1 * 1/2n + 2 * 1/2n + n * 1/2n + 1/2 * n = (3n+1)/4</p>
</blockquote>
<p>这个值就是概率论中的<code>加权平均值</code>，也叫作<code>期望值</code>，所以平均时间复杂度的全称应该叫<code>加权平均时间复杂度</code>或者<code>期望时间复杂度</code>。<br>
引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。<br>
你可能会说，平均时间复杂度分析好复杂啊，还要涉及概率论的知识。实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。<br>
很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。</p>
<h4 id="均摊时间复杂度">均摊时间复杂度</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="c1">// array 表示一个长度为 n 的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 代码中的 array.length 就等于 n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="p">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">array</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">array</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，<br>
将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。<br>
最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p>
<p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。<br>
除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。<br>
而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是</p>
<blockquote>
<p>1 * 1/(n+1) + 1 * 1/(n+1)+&hellip;+ n * 1/(n+1) = O(1)</p>
</blockquote>
<p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()第一个区别于 find() 的地方。<br>
我们再来看第二个不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p>
<p>所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。<br>
针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。</p>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<p>均摊时间复杂度就是一种特殊的平均时间复杂度，我们没必要花太多精力去区分它们。你最应该掌握的是它的分析方法，摊还分析.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="c1">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 往数组中添加一个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 数组空间不够了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 重新申请一个 2 倍大小的数组空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">new_array</span><span class="p">[]</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">len</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 把原来 array 数组中的数据依次 copy 到 new_array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">new_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// new_array 复制给 array，array 现在大小就是 2 倍 len 了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">array</span> <span class="o">=</span> <span class="n">new_array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 element 放到下标为 i 的位置，下标 i 加一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>最好是O(1)，最差是O(n), 均摊是O(1)</p>
</blockquote>
<hr>
<h3 id="空间复杂度">空间复杂度</h3>
<p>类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<h2 id="基础数据结构">基础数据结构</h2>
<h3 id="线性表">线性表</h3>
<blockquote>
<p>数组, 链表, 队列, 栈</p>
</blockquote>
<h4 id="数组">数组</h4>
<blockquote>
<p>一组连续的内存空间,存放一组相同数据类型的数据, 由于CPU访问存储器的<a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902">局部性原理</a>, 所以数组比链表高效</p>
</blockquote>
<p>访问: 根据下标任意访问的时间复杂度为O（1）,
插入: 从最好O(1) 最坏O(n) 平均O(n)
删除: 从最好O(1) 最坏O(n) 平均O(n)</p>
<p>多次删除集中在一起，提高删除效率
记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello world</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>以上代码会死循环执行, 栈设计采用小端模式的系统才会出现</p>
</blockquote>
<p>例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素 加上一个变量a 。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面 导致死循环<br>
如果数组长度为4 且循环5次 则这里不会出现死循环。因为编译器64位操作系统下 默认会进行8字节对齐 变量i的地址就不紧跟着数组后面了。</p>
<blockquote>
<p>存疑1: 当长度为4 无法解释. 压栈顺序: i，a[2]，a[1]，a[0], 所以 a[3]访问到的是i<br>
存疑2: gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管i声明在前还是在后，i都会在数组之后压栈，只会循环4次；如果关闭堆栈保护功能，则会出现死循环.</p>
</blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html">参考 GCC编译器堆栈保护技术</a>
<a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.4_gcc_sec.html">GCC 堆栈保护技术</a></p>
<p><strong><code>容器和数组</code></strong></p>
<blockquote>
<p>众多语言都有对数组封装好的容器类</p>
</blockquote>
<p>Java 中 ArrayList 和 数组的对比</p>
<p>优势</p>
<ol>
<li>对数组操作的细节进行封装,</li>
<li>支持动态扩容, 空间不够会扩容为原大小的1.5倍
劣势</li>
<li>ArrayList 无法存放基础数据类型, 只能用包装类型, 这样就涉及到了 自动拆装箱,影响性能</li>
<li>表示二维结构数据时, 没有数组直观</li>
</ol>
<blockquote>
<p>最好在创建 ArrayList的时候设置好初始大小,避免不必要的数据搬运
对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>
</blockquote>
<h4 id="链表">链表</h4>
<blockquote>
<p>单链表 双向链表 循环链表</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/Kuangcp/LearnC/tree/master/algorithm/linked_lists">Github: C语言代码实现</a><code>个人</code></p>
</blockquote>
<h4 id="数组和链表对比">数组和链表对比</h4>
<table>
<thead>
<tr>
<th style="text-align:center">操作\时间复杂度</th>
<th style="text-align:center">数组</th>
<th style="text-align:center">链表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入/删除</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">随机访问</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(n)</td>
</tr>
</tbody>
</table>
<hr>
<p>分治算法
动态规划 最值 极值
不直接找问题, 而是根据你的输入, 和答案之前关系的规律</p>
<p>柯里化, continuation 高阶函数, 尾递归</p>
<h3 id="树">树</h3>
<blockquote>
<p>Radix 树 这是一种基于二进制表示的键值的查找树，尤其适合处理非常长的、可变长度的键值</p>
</blockquote>
<hr>
<h2 id="匹配算法">匹配算法</h2>
<ul>
<li><a href="http://zjwyhll.blog.163.com/blog/static/75149781201281142630851/">字符串相似度匹配</a></li>
</ul>
<h2 id="排序算法">排序算法</h2>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/34421623?group_id=955945213303250944">参考: 九种排序算法的可视化及比较</a></p>
</blockquote>
<h2 id="搜索算法">搜索算法</h2>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Trie">Trie</a> <code>字典树</code></p>
</blockquote>
<h2 id="哈希算法">哈希算法</h2>
<blockquote>
<p>也称 散列法 关键字地址计算法</p>
</blockquote>
<p>基本思想: 在元素的关键字 k 和元素的存储位置 p 之间建立一个对应关系 H, 使得 p = H(k)，则 H 被称为哈希函数</p>
<ul>
<li>
<p>在创建哈希表时, 把关键字为 k 的元素放到地址为 H(k) 的单元</p>
</li>
<li>
<p>在查找时则根据关键字 k 计算出地址, 直接获取到元素, 时间复杂度达到 O(1)</p>
</li>
<li>
<p>MD5</p>
</li>
<li>
<p>SHA</p>
<ul>
<li>SHA家族算法有SHA-1、SHA-224、SHA-256、SHA-384和SHA-512（后四者通常并称SHA2）</li>
</ul>
</li>
<li>
<p>CRC</p>
<ul>
<li>循环冗余校验, CRC32（12、16、32等值均是指多项式的最高阶N次幂）</li>
</ul>
</li>
<li>
<p>MurmurHash</p>
<ul>
<li>是一种非加密型哈希函数，和其它流行哈希函数相比，对于规律性较强的 key 随机分布特性表现更良好，很多开源的软件项目使用（Redis，Memcached，Cassandra，HBase，Lucene）</li>
</ul>
</li>
<li>
<p>Bcrypt <code>慢Hash函数</code></p>
</li>
</ul>
<h3 id="hash函数构造">HASH函数构造</h3>
<p>设计哈希函数常考虑</p>
<ol>
<li>哈希函数的时间复杂度</li>
<li>关键字长度</li>
<li>哈希表大小</li>
<li>关键字分布的情况</li>
<li>记录查找的频率</li>
</ol>
<p>常见设计思路:</p>
<p><code>数字分析法</code>
事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时, 可以从关键字中选出分布较均匀的若干位, 构成哈希地址</p>
<p><code>平方取中法</code>
当无法确定关键字中哪几位分布较均匀时, 可以先求出关键字的平方值， 然后依据需要取平方值的中间几位作为哈希地址<br>
因为平方运算后中间几位和关键字中每一位都相关，所以散列程度比较高</p>
<p><code>分段叠加法</code>
按哈希表地址位数, 将关键字分成位数相等的几部分, 后面多余的部分可以截断, 然后将这几部分移位相加或者折叠相加, 求得哈希值</p>
<p><code>除留余数法</code>
哈希表长为m, p为小于等于m的最大素数, 哈希函数则是 <code>H(k)=k%p</code> 该方法容易产生哈希冲突</p>
<p><code>伪随机数法</code>
直接使用随机数函数 <code>H(k)=random(k)</code></p>
<p><code>JDK中的HashMap实现方式</code>
取键值的hashCode, 然后高低16位做异或运算, 然后再与<code>哈希表大小</code>做与运算, 才得到哈希地址</p>
<h3 id="hash-冲突">HASH 冲突</h3>
<blockquote>
<p><a href="http://www.cnblogs.com/jillzhang/archive/2006/11/03/548671.html">参考: hash是如何处理冲突的?</a></p>
</blockquote>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/92194?utm_campaign=wenzhang&amp;utm_medium=article&amp;utm_source=QQ-qun&amp;201762&amp;utm_content=m_22308">参考: 一种高级的DoS攻击-Hash碰撞攻击 </a>
<a href="https://stackoverflow.com/questions/8669946/application-vulnerability-due-to-non-random-hash-functions">Application vulnerability due to Non Random Hash Functions</a></p>
</blockquote>
<h4 id="开放定址法">开放定址法</h4>
<ul>
<li>
<p>开放定址法有一个公式: <code>Hi=(H(key)+di) % m; i=1,2,...,k(k&lt;=m-1)</code></p>
<ul>
<li>其中 m 为哈希表的表长 di 是产生冲突的时候的<code>增量序列</code></li>
</ul>
</li>
<li>
<p>线性探查法</p>
<ul>
<li>如果di值可能为1,2,3,&hellip;m-1, 顺序查看表单元, 直到找到空单元。</li>
</ul>
</li>
<li>
<p>平方探测法</p>
<ul>
<li>如果di取1，则每次冲突之后，向后移动1个位置. 如果di取值可能为 <code>1,-1^2,2^2,-2^2,...k*k,-k*k (k&lt;=m/2)</code></li>
</ul>
</li>
<li>
<p>伪随机探测</p>
<ul>
<li>di取值是伪随机数列</li>
</ul>
</li>
</ul>
<blockquote>
<p>优点</p>
</blockquote>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li>当冲突多的时候数据容易堆集在一起，这时候对查找不友好；</li>
<li>删除结点的时候不能简单将结点的空间置空，否则将截断在它填入散列表之后的同义词结点查找路径。因此如果要删除结点，只能在被删结点上添加删除标记，而不能真正删除结点；</li>
<li>如果哈希表的空间已经满了，还需要建立一个溢出表，来存入多出来的元素。</li>
</ol>
<h4 id="再-hash-法">再 HASH 法</h4>
<p>基本思想是构造多个不同的哈希函数, 当发生冲突时，使用第二个、第三个哈希函数计算地址，直到无冲突。</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>增加了时间复杂度</p>
<h4 id="链地址拉链-法">链地址/拉链 法</h4>
<p>将所有哈希地址为 i 的元素构成一个<code>同义词链</code>的单链表, 因此适用于频繁插入删除的情况</p>
<p>JDK中的HashMap（JDK8链表部分引入红黑树），Golang的map 均采用该方式</p>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li>处理冲突的方式简单，且无堆集现象，非同义词绝不会发生冲突，因此平均查找长度较短；</li>
<li>由于拉链法中各链表上的结点空间是动态申请的，所以它更适合造表前无法确定表长的情况；</li>
<li>删除结点操作易于实现，只要简单地删除链表上的相应的结点即可。</li>
</ol>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li>需要额外的存储空间</li>
</ol>
<h4 id="公共溢出区">公共溢出区</h4>
<ul>
<li>假设哈希函数的值域为<code>[0,m-1]</code>, 则设向量<code>HashTable[0..m-1]</code>为基本表，另外设立存储空间向量 <code>OverTable[0..v]</code> 用以存储发生冲突的记录。</li>
</ul>
<p>凡是和基本表发生冲突的元素一律填入溢出表</p>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li>查找冲突数据的时候，需要遍历溢出表才能得到数据</li>
</ol>
<hr>
<h3 id="安全相关">安全相关</h3>
<ol>
<li>HASH攻击，例如针对Java中HashMap的算法，通过构造特定的参数，使得HashMap退化为链表，浪费服务器资源</li>
<li>不同的参数进入Hash函数运行时间会不一致，理论上利用这一点可以提高爆破密码的准确性，所以JDK中实现尽量保证了hash时间均匀</li>
</ol>
<hr>
<h1 id="密码学">密码学</h1>
<h2 id="diffie-hellman-key-exchange算法">Diffie-Hellman Key Exchange算法</h2>
<blockquote>
<p>Whitfield Diffie 和 Martin Hellman ，他们于2015年获得了计算机科学领域的最高奖：图灵奖</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/arithmetic/Diffie-HellmanKeyExchange.png" alt="码农翻身"></p>
<p><code>最后神奇的魔法发生了， 我们两个得到了同样的值 s = 10！</code></p>
<ul>
<li>这个s 的值只有我们两个才知道，  其实就是密钥了， 可以用来做加密解密了（ 当然，这只是一个例子，实际的密钥不会这么短）， 我们俩的通讯从此就安全了。
<ul>
<li>“数学家小帅哥说了， 原因很简单，(gｘ mod p)ｙ mod p　和　(gｙ mod p)ｘ mod p　是相等的！ ”</li>
<li>“那黑客不能从公开传输的 p = 17, g = 3, a = 6 , b = 12 推算出s = 10 吗？” 我问道。</li>
<li>“当然不能， 不过前提是需要使用非常大的p , x, y,  这样以来，即使黑客动用地球上所有的计算资源， 也推算不出来。 ”</li>
</ul>
</li>
</ul>
<h1 id="实际问题">实际问题</h1>
<p>例如存储一个部门关系, 上下级, 以及同级要有序, 并且, 这个关系树是能随意调整结构的, 每个节点和节点之间任意断开和连接</p>
<p>name/id, parent, index</p>
<h2 id="斐波那契数列">斐波那契数列</h2>
<blockquote>
<p><a href="https://open.163.com/movie/2014/2/N/O/M9HKRT25D_M9HNA0UNO.html">神奇的斐波那契数列</a> | <a href="https://www.zhihu.com/question/28062458">斐波那契数列为什么那么重要</a></p>
</blockquote>
<p>斐波那契数列: 递归, 离散数学, 斐波那契博弈
数据结构: 斐波那契堆,
算法: 分治, 动态规划, 并行算法, 矩阵积, fft
操作系统 线程, 线程级并行, openmp</p>
<p>二分搜索: 斐波那契数列实际上体现的是自然界某些情形下更本质的平权意识，尤其是当表面上的「对半法」实际上并不能做到平权时。自然情况下，对半分不一定就是平权，而黄金分割才是更本质意义下的平权<br>
<code>mid = (hi + low) /2</code> =&gt; <code>mid = low + fib.get() - 1;</code></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Mythos</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2018-11-21
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/skills/ecology/msa/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">微服务</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/skills/regularexpression/">
            <span class="next-text nav-default">正则表达式</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="http://github.com/kuangcp" class="iconfont icon-github" title="github"></a>
  <a href="https://blogs.kuangcp.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://gitee.com/gin9/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2016 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span>
    <span>Mythos</span>
    
    <br/><span><a href='https://beian.miit.gov.cn/'; target=_blank>赣ICP备17014189号-1</a></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>








</body>
</html>
