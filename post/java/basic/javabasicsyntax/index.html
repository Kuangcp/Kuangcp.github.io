<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java基础语法 - Mythos · Java Developer</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Kuangcp" /><meta name="description" content="💠 基础语法 1.1. 代码风格 1.2. 结构 1.2.1. 判断 1.2.2. 循环 1.3. 标准输入输出 1.4. Runtime 数据类型 2.1. 自动拆装箱 2.2. 基础数据类型 2.2.1. byte 2.2.2. char 2.2.3. boolean 2.2.4. short 2.2.5. int 2.2.6. long 2.2.7. float 2.2.8. double 2.3. 封装类型 2.3.1. String 2.3.2. Float" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.99.0 with theme even" />


<link rel="canonical" href="https://www.kuangcp.top/post/java/basic/javabasicsyntax/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java基础语法" />
<meta property="og:description" content="💠 基础语法 1.1. 代码风格 1.2. 结构 1.2.1. 判断 1.2.2. 循环 1.3. 标准输入输出 1.4. Runtime 数据类型 2.1. 自动拆装箱 2.2. 基础数据类型 2.2.1. byte 2.2.2. char 2.2.3. boolean 2.2.4. short 2.2.5. int 2.2.6. long 2.2.7. float 2.2.8. double 2.3. 封装类型 2.3.1. String 2.3.2. Float" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.kuangcp.top/post/java/basic/javabasicsyntax/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-11-21T10:56:52+00:00" />
<meta property="article:modified_time" content="2018-11-21T10:56:52+00:00" />

<meta itemprop="name" content="Java基础语法">
<meta itemprop="description" content="💠 基础语法 1.1. 代码风格 1.2. 结构 1.2.1. 判断 1.2.2. 循环 1.3. 标准输入输出 1.4. Runtime 数据类型 2.1. 自动拆装箱 2.2. 基础数据类型 2.2.1. byte 2.2.2. char 2.2.3. boolean 2.2.4. short 2.2.5. int 2.2.6. long 2.2.7. float 2.2.8. double 2.3. 封装类型 2.3.1. String 2.3.2. Float"><meta itemprop="datePublished" content="2018-11-21T10:56:52+00:00" />
<meta itemprop="dateModified" content="2018-11-21T10:56:52+00:00" />
<meta itemprop="wordCount" content="6362">
<meta itemprop="keywords" content="基础,语法," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java基础语法"/>
<meta name="twitter:description" content="💠 基础语法 1.1. 代码风格 1.2. 结构 1.2.1. 判断 1.2.2. 循环 1.3. 标准输入输出 1.4. Runtime 数据类型 2.1. 自动拆装箱 2.2. 基础数据类型 2.2.1. byte 2.2.2. char 2.2.3. boolean 2.2.4. short 2.2.5. int 2.2.6. long 2.2.7. float 2.2.8. double 2.3. 封装类型 2.3.1. String 2.3.2. Float"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Mythos</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Mythos</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java基础语法</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-11-21 </span>
        <div class="post-category">
            <a href="/categories/java/"> Java </a>
            </div>
          <span class="more-meta"> 约 6362 字 </span>
          <span class="more-meta"> 预计阅读 13 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#基础语法">基础语法</a>
      <ul>
        <li><a href="#代码风格">代码风格</a></li>
        <li><a href="#结构">结构</a>
          <ul>
            <li><a href="#判断">判断</a></li>
            <li><a href="#循环">循环</a></li>
          </ul>
        </li>
        <li><a href="#标准输入输出">标准输入输出</a></li>
        <li><a href="#runtime">Runtime</a></li>
      </ul>
    </li>
    <li><a href="#数据类型">数据类型</a>
      <ul>
        <li><a href="#自动拆装箱">自动拆装箱</a></li>
        <li><a href="#基础数据类型">基础数据类型</a>
          <ul>
            <li><a href="#byte">byte</a></li>
            <li><a href="#char">char</a></li>
            <li><a href="#boolean">boolean</a></li>
            <li><a href="#short">short</a></li>
            <li><a href="#int">int</a></li>
            <li><a href="#long">long</a></li>
            <li><a href="#float">float</a></li>
            <li><a href="#double">double</a></li>
          </ul>
        </li>
        <li><a href="#封装类型">封装类型</a>
          <ul>
            <li><a href="#string">String</a></li>
            <li><a href="#float-1">Float</a></li>
            <li><a href="#double-1">Double</a></li>
            <li><a href="#integer">Integer</a></li>
            <li><a href="#long-1">Long</a></li>
            <li><a href="#boolean-1">Boolean</a></li>
            <li><a href="#void">Void</a></li>
            <li><a href="#decimal">Decimal</a></li>
          </ul>
        </li>
        <li><a href="#枚举类型">枚举类型</a></li>
        <li><a href="#内部类">内部类</a></li>
        <li><a href="#匿名类">匿名类</a></li>
        <li><a href="#类型强转">类型强转</a></li>
        <li><a href="#时间类型">时间类型</a></li>
        <li><a href="#非原生类型">非原生类型</a>
          <ul>
            <li><a href="#元组">元组</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#运算">运算</a>
      <ul>
        <li><a href="#除法">除法</a></li>
        <li><a href="#取余">取余</a></li>
        <li><a href="#位运算">位运算</a></li>
      </ul>
    </li>
    <li><a href="#类的结构">类的结构</a>
      <ul>
        <li><a href="#import">import</a></li>
        <li><a href="#修饰符">修饰符</a>
          <ul>
            <li><a href="#权限修饰符">权限修饰符</a></li>
            <li><a href="#final">final</a></li>
            <li><a href="#static">static</a></li>
            <li><a href="#abstract">abstract</a></li>
          </ul>
        </li>
        <li><a href="#成员属性">成员属性</a></li>
        <li><a href="#方法">方法</a>
          <ul>
            <li><a href="#方法的传参方式">方法的传参方式</a></li>
            <li><a href="#equals">equals</a></li>
            <li><a href="#hashcode">hashcode</a></li>
            <li><a href="#finalize">finalize</a></li>
          </ul>
        </li>
        <li><a href="#javadoc">JavaDoc</a></li>
      </ul>
    </li>
    <li><a href="#抽象类">抽象类</a></li>
    <li><a href="#对象">对象</a></li>
    <li><a href="#继承和接口">继承和接口</a>
      <ul>
        <li><a href="#常见接口">常见接口</a>
          <ul>
            <li><a href="#serializable">Serializable</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#object">Object</a>
      <ul>
        <li><a href="#vo">VO</a></li>
        <li><a href="#po">PO</a></li>
        <li><a href="#to">TO</a></li>
        <li><a href="#bo">BO</a></li>
        <li><a href="#pojo">POJO</a></li>
        <li><a href="#dao">DAO</a></li>
      </ul>
    </li>
    <li><a href="#关键字">关键字</a>
      <ul>
        <li><a href="#try">try</a></li>
        <li><a href="#transient">transient</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注意】最后更新于 <span class="timeago" datetime="2018-11-21T10:56:52" title="November 21, 2018">November 21, 2018</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
    <div class="post-content">
      <p>💠</p>
<ul>
<li>
<ol>
<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">基础语法</a></li>
</ol>
<ul>
<li>1.1. <a href="#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC">代码风格</a></li>
<li>1.2. <a href="#%E7%BB%93%E6%9E%84">结构</a>
<ul>
<li>1.2.1. <a href="#%E5%88%A4%E6%96%AD">判断</a></li>
<li>1.2.2. <a href="#%E5%BE%AA%E7%8E%AF">循环</a></li>
</ul>
</li>
<li>1.3. <a href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">标准输入输出</a></li>
<li>1.4. <a href="#runtime">Runtime</a></li>
</ul>
</li>
<li>
<ol start="2">
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
</ol>
<ul>
<li>2.1. <a href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1">自动拆装箱</a></li>
<li>2.2. <a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基础数据类型</a>
<ul>
<li>2.2.1. <a href="#byte">byte</a></li>
<li>2.2.2. <a href="#char">char</a></li>
<li>2.2.3. <a href="#boolean">boolean</a></li>
<li>2.2.4. <a href="#short">short</a></li>
<li>2.2.5. <a href="#int">int</a></li>
<li>2.2.6. <a href="#long">long</a></li>
<li>2.2.7. <a href="#float">float</a></li>
<li>2.2.8. <a href="#double">double</a></li>
</ul>
</li>
<li>2.3. <a href="#%E5%B0%81%E8%A3%85%E7%B1%BB%E5%9E%8B">封装类型</a>
<ul>
<li>2.3.1. <a href="#string">String</a></li>
<li>2.3.2. <a href="#float">Float</a></li>
<li>2.3.3. <a href="#double">Double</a></li>
<li>2.3.4. <a href="#integer">Integer</a></li>
<li>2.3.5. <a href="#long">Long</a></li>
<li>2.3.6. <a href="#boolean">Boolean</a></li>
<li>2.3.7. <a href="#void">Void</a></li>
<li>2.3.8. <a href="#decimal">Decimal</a></li>
</ul>
</li>
<li>2.4. <a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">枚举类型</a></li>
<li>2.5. <a href="#%E5%86%85%E9%83%A8%E7%B1%BB">内部类</a></li>
<li>2.6. <a href="#%E5%8C%BF%E5%90%8D%E7%B1%BB">匿名类</a></li>
<li>2.7. <a href="#%E7%B1%BB%E5%9E%8B%E5%BC%BA%E8%BD%AC">类型强转</a></li>
<li>2.8. <a href="#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B">时间类型</a></li>
<li>2.9. <a href="#%E9%9D%9E%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B">非原生类型</a>
<ul>
<li>2.9.1. <a href="#%E5%85%83%E7%BB%84">元组</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="3">
<li><a href="#%E8%BF%90%E7%AE%97">运算</a></li>
</ol>
<ul>
<li>3.1. <a href="#%E9%99%A4%E6%B3%95">除法</a></li>
<li>3.2. <a href="#%E5%8F%96%E4%BD%99">取余</a></li>
<li>3.3. <a href="#%E4%BD%8D%E8%BF%90%E7%AE%97">位运算</a></li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84">类的结构</a></li>
</ol>
<ul>
<li>4.1. <a href="#import">import</a></li>
<li>4.2. <a href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6">修饰符</a>
<ul>
<li>4.2.1. <a href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6">权限修饰符</a></li>
<li>4.2.2. <a href="#final">final</a></li>
<li>4.2.3. <a href="#static">static</a></li>
<li>4.2.4. <a href="#abstract">abstract</a></li>
</ul>
</li>
<li>4.3. <a href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7">成员属性</a></li>
<li>4.4. <a href="#%E6%96%B9%E6%B3%95">方法</a>
<ul>
<li>4.4.1. <a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F">方法的传参方式</a></li>
<li>4.4.2. <a href="#equals">equals</a></li>
<li>4.4.3. <a href="#hashcode">hashcode</a></li>
<li>4.4.4. <a href="#finalize">finalize</a></li>
</ul>
</li>
<li>4.5. <a href="#javadoc">JavaDoc</a></li>
</ul>
</li>
<li>
<ol start="5">
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a></li>
</ol>
</li>
<li>
<ol start="6">
<li><a href="#%E5%AF%B9%E8%B1%A1">对象</a></li>
</ol>
</li>
<li>
<ol start="7">
<li><a href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%A5%E5%8F%A3">继承和接口</a></li>
</ol>
<ul>
<li>7.1. <a href="#%E5%B8%B8%E8%A7%81%E6%8E%A5%E5%8F%A3">常见接口</a>
<ul>
<li>7.1.1. <a href="#serializable">Serializable</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="8">
<li><a href="#object">Object</a></li>
</ol>
<ul>
<li>8.1. <a href="#vo">VO</a></li>
<li>8.2. <a href="#po">PO</a></li>
<li>8.3. <a href="#to">TO</a></li>
<li>8.4. <a href="#bo">BO</a></li>
<li>8.5. <a href="#pojo">POJO</a></li>
<li>8.6. <a href="#dao">DAO</a></li>
</ul>
</li>
<li>
<ol start="9">
<li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a></li>
</ol>
<ul>
<li>9.1. <a href="#try">try</a></li>
<li>9.2. <a href="#transient">transient</a></li>
</ul>
</li>
</ul>
<p>💠 2024-10-08 15:07:46</p>
<hr>
<h1 id="基础语法">基础语法</h1>
<p><img src="/Java/AdvancedLearning/img/005-java-main.km.svg" alt=""></p>
<h2 id="代码风格">代码风格</h2>
<blockquote>
<p><a href="https://github.com/google/styleguide">Google Style Guide</a> | <a href="/Java/AlibabaJavaStandard.md">阿里巴巴开发手册</a></p>
</blockquote>
<h2 id="结构">结构</h2>
<h3 id="判断">判断</h3>
<ul>
<li>if</li>
<li>switch</li>
</ul>
<h3 id="循环">循环</h3>
<ul>
<li>while
<ul>
<li><code>while(true){}</code></li>
<li><code>do{}while(true);</code></li>
</ul>
</li>
<li>for 循环
<ul>
<li><code>for(int a=0; i&lt;10; i++){}</code></li>
</ul>
</li>
<li>for each循环
<ul>
<li><code>for(Object item:list){}</code> 注意 list对象如果是通过<code>调用一个对象的方法</code>返回的，那么只会调用一次该方法</li>
</ul>
</li>
</ul>
<h2 id="标准输入输出">标准输入输出</h2>
<blockquote>
<p>系统标准输入</p>
</blockquote>
<ul>
<li><code>Scanner scanner = new Scanner(System.in);</code></li>
</ul>
<blockquote>
<p>系统标准输出</p>
</blockquote>
<ul>
<li><code>System.out.println(&quot;&quot;)</code> 并在末尾追加换行
<ul>
<li>.print() 输出, 行末不换行</li>
<li>.printf() 格式化输出, 和C语法类似</li>
</ul>
</li>
</ul>
<h2 id="runtime">Runtime</h2>
<blockquote>
<p>获取操作系统信息，JVM运行时操作</p>
</blockquote>
<ul>
<li>获取空闲堆内存 Runtime.getRuntime().freeMib();</li>
<li></li>
</ul>
<hr>
<h1 id="数据类型">数据类型</h1>
<blockquote>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive Data Types</a></p>
</blockquote>
<h2 id="自动拆装箱">自动拆装箱</h2>
<blockquote>
<p>在日常Java开发中, 基本数据类型和包装类型是可以视为等价的(唯一差别就是包装类型能表达null), 就是因为自动拆装箱的存在</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">基本数据类型</th>
<th style="text-align:left">包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">Byte</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">Character</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">Boolean</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">Short</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">Integer</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">Long</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">Float</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">Double</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">Void</td>
</tr>
</tbody>
</table>
<blockquote>
<p>区别</p>
</blockquote>
<ul>
<li>存储方式及位置的不同，基本类型是直接存储变量的值保存在堆栈中能高效的存取，包装类型需要通过引用指向实例，具体的实例保存在堆中。</li>
<li>初始值的不同，封装类型的初始值为 null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；</li>
<li>使用方式的不同, 在泛型场合只能使用包装类型, 基本类型无法表达 null</li>
</ul>
<blockquote>
<p>存在的意义</p>
</blockquote>
<ol>
<li>基本类型无法作为对象看待, 扩充了语义</li>
<li>为了泛型</li>
</ol>
<blockquote>
<p>弊端</p>
</blockquote>
<ol>
<li>性能问题, 需要构造对象</li>
</ol>
<hr>
<blockquote>
<p>注意自动拆装箱是编译器的语法糖<br>
自动装箱都是通过包装类的 valueOf() 方法来实现的.<br>
自动拆箱都是通过包装类对象的 xxxValue() 来实现的.</p>
</blockquote>
<h2 id="基础数据类型">基础数据类型</h2>
<blockquote>
<p>八种基本数据类型 byte char boolean short int long float double</p>
</blockquote>
<p>以特定进制声明数值 0b 二进制 0 八进制 0x 十六进制</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">The Java™ Tutorials: Primitive Data Types</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.yinwang.org/blog-cn/2016/06/08/java-value-type">参考: Java 有值类型吗？</a></p>
</blockquote>
<p>确实, 这样来看Java没有值类型才是更统一的, 不过有没有对程序都是一样的, 因为Java没有解引用, 基本数据类型又没有成员, 所以值还是引用, 没差</p>
<h3 id="byte">byte</h3>
<blockquote>
<p>字节 -128, 127, 表示 8位 一个字节 的值</p>
</blockquote>
<h3 id="char">char</h3>
<p>用 2 个字节来表示 Unicode 值 取值范围: &lsquo;\u0000&rsquo; (or 0) , &lsquo;\uffff&rsquo; (or 65,535 inclusive).</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/5078314/isnt-the-size-of-character-in-java-2-bytes">参考: isn&rsquo;t the size of character in java 2 bytes</a></p>
</blockquote>
<h3 id="boolean">boolean</h3>
<blockquote>
<p><a href="https://www.jianshu.com/p/2f663dc820d0">参考 你真的知道Java中boolean类型占用多少个字节吗？</a></p>
</blockquote>
<h3 id="short">short</h3>
<h3 id="int">int</h3>
<blockquote>
<p>数值范围 -2^31,2^31-1 int占四个字节 32位 一位是符号位</p>
</blockquote>
<p>Java8 以上可以使用无符号的 int, 值范围: 0, 2^32-1</p>
<h3 id="long">long</h3>
<blockquote>
<p>数值范围 -2^63 2^63-1 占八个字节 64位 一位是符号位</p>
</blockquote>
<p>Java8 以上可以使用无符号的 long, 值范围: 0, 2^64-1</p>
<h3 id="float">float</h3>
<h3 id="double">double</h3>
<hr>
<h2 id="封装类型">封装类型</h2>
<blockquote>
<p><code>wrapper class</code> 基本类型和包装类型不能混为一谈 本质上的 class是不同的, 只不过自动拆装箱才让人感觉没差别</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Integer.TYPE</td>
<td style="text-align:left">int.class</td>
</tr>
<tr>
<td style="text-align:left">Byte.TYPE</td>
<td style="text-align:left">byte.class</td>
</tr>
<tr>
<td style="text-align:left">Boolean.TYPE</td>
<td style="text-align:left">boolean.class</td>
</tr>
<tr>
<td style="text-align:left">Double.TYPE</td>
<td style="text-align:left">double.class</td>
</tr>
<tr>
<td style="text-align:left">Void.TYPE</td>
<td style="text-align:left">void.class</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>封装类型的缓存行为</p>
</blockquote>
<p>Integer, 有 IntegerCache 类缓存了 [-128, 127] 范围内的值. 可以通过 <code>-XX:AutoBoxCacheMax</code> 参数修改上限值<br>
且 Byte Short Long Character 都有对应的缓存对象和缓存值范围, <strong>但是只有Integer的缓存范围可变</strong></p>
<p>Byte, Short, Long 有固定范围: [-128, 127]<br>
Character  范围是 ‘\u0000’ 至 ‘\u007f’ 即 [0,127]</p>
<p>true 和 false 也是缓存了的</p>
<blockquote>
<p>可能造成的困惑</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">128</span><span class="o">)</span> <span class="o">!=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">128</span><span class="o">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="string">String</h3>
<blockquote>
<p>该类是final修饰的, 原因:<a href="https://www.zhihu.com/question/31345592">知乎问题</a></p>
</blockquote>
<p>字符串对象是不可变的，这意味着一旦创建，它们的值就不能更改。 String类在技术上不是基本数据类型，但考虑到语言给予它的特殊支持，倾向于将其视为基本数据类型。</p>
<ul>
<li>常量池
<ul>
<li>存放于方法区(虚拟机规范中所声明)内，依据不同的JVM实现
<ul>
<li>方法区实现的存储位置也不一致，在JDK 7以前的版本中，字符串常量池是放在永久代中的。在JDK 7中，放于堆内存中。 在JDK 8中，彻底移除了永久代，放在元空间中</li>
</ul>
</li>
<li><a href="https://segmentfault.com/a/1190000009888357">String：字符串常量池</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="/Java/Basic/StringConcat.md">字符串拼接</a></p>
</blockquote>
<h3 id="float-1">Float</h3>
<h3 id="double-1">Double</h3>
<h3 id="integer">Integer</h3>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html">BigInteger</a></p>
</blockquote>
<h3 id="long-1">Long</h3>
<blockquote>
<p><a href="https://www.javamex.com/java_equivalents/unsigned_arithmetic.shtml">Unsigned arithmetic in Java</a><br>
<a href="https://stackoverflow.com/questions/508630/java-equivalent-of-unsigned-long-long">Java equivalent of unsigned long long?</a></p>
</blockquote>
<p>无符号Long: <code>Long.parseUnsignedLong();</code> <code>Long.toUnsignedString();</code></p>
<blockquote>
<p><a href="https://www.cnblogs.com/yuanyq/p/java_unsigned_types.html">参考: Java 中的无符号类型是怎么回事儿？</a></p>
</blockquote>
<h3 id="boolean-1">Boolean</h3>
<blockquote>
<p>内含两个单例 TRUE FALSE</p>
</blockquote>
<p>但是能通过反射修改两个单例的值，导致逻辑错乱 <a href="https://github.com/Kuangcp/JavaBase/blob/d43a97f458862f8ac5f9adf1b46ff98310518465/class/src/test/java/com/github/kuangcp/reflects/ReflectTargetObjectTest.java">com.github.kuangcp.reflects.ReflectTargetObjectTest#testModifyStaticFinalBoolean</a></p>
<h3 id="void">Void</h3>
<ul>
<li>void 的包装类型, 常用于反射时对应上 返回值为void的方法(总得有个类型 Void.TYPE) 该类型在 jdk1.1就有了, 1.5出了泛型后, 又多了一个用途(因为泛型不支持原始类型)</li>
</ul>
<blockquote>
<p>The Void class is an uninstantiable placeholder class to hold a reference to the Class object representing the Java keyword void.</p>
</blockquote>
<blockquote>
<p><a href="https://stackoverflow.com/questions/2352447/what-is-the-need-of-void-class-in-java">参考: What is the need of Void class in Java</a></p>
</blockquote>
<blockquote>
<p><a href="https://stackoverflow.com/questions/643906/uses-for-the-java-void-reference-type">参考: Uses for the Java Void Reference Type?</a></p>
</blockquote>
<ol>
<li>在AOP中, 增强根据切点的返回值类型, 做出不同的逻辑, 有可能用到Void</li>
<li>Void 强调 the nothing, null 强调 nothing</li>
<li>Void 作为方法的返回值时, 只能返回 null</li>
</ol>
<ul>
<li>案例:
<ul>
<li>Future<Void></li>
<li>ResponseEntity<Void></li>
<li>A <code>Consumer&lt;T&gt;</code> can be viewed as a <code>Function&lt;T, Void&gt;</code>, 没有返回值,只有入参</li>
<li>A <code>Supplier&lt;T&gt;</code> can be viewed as a <code>Function&lt;Void, T&gt;</code>, 没有入参,只有返回值</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">official api</a></p>
</blockquote>
<blockquote>
<p>When you use the visitor pattern it can be cleaner to use Void instead of Object when you want to be sure that the return value will be null. Example:</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">LeavesVisitor</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;{</span>
</span></span><span class="line"><span class="cl">        <span class="n">OUT</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Leaf1</span> <span class="n">leaf</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">OUT</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Leaf2</span> <span class="n">leaf</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>When you will implement your visitor you can explicitly set OUT to be Void so that you know your visitor will always return null, instead of using Object</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyVoidVisitor</span> <span class="kd">implements</span> <span class="n">LeavesVisitor</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Leaf1</span> <span class="n">leaf</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//...do what you want on your leaf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">Leaf2</span> <span class="n">leaf</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//...do what you want on your leaf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="decimal">Decimal</h3>
<p>通常进行浮点数间运算的时候，如果没有太在意小数位的精度问题，可以直接使用Double，如果是金额之类的业务值则需要使用到BigDecimal</p>
<p>注意事项：</p>
<ul>
<li>
<p>构造方式</p>
<ul>
<li>double入参构造器容易出现问题，例如 new BigDecimal(0.1) 最终不是期望的0.1 因为浮点数表示0.1是不精确的，应该改成 new BigDecimal(&ldquo;0.1&rdquo;)</li>
</ul>
</li>
<li>
<p>计算</p>
<ul>
<li>参与计算的项不能出现null</li>
<li>BigDecimal 计算过程需要使用BigDecimal的方法，而不是直接进行加减乘除。例如 <code>new BigDecimal(a/b);</code></li>
<li>divide方法注意无限循环小数（设置精度规模规避）以及除数为0的情况</li>
</ul>
</li>
<li>
<p>值比较</p>
<ul>
<li>不能直接用 == 或者 equals，而是走 Comparable接口方式 compareTo()</li>
</ul>
</li>
<li>
<p>常见值优先使用BigDecimal的枚举，例如BigDecimal.ZERO</p>
</li>
</ul>
<hr>
<h2 id="枚举类型">枚举类型</h2>
<blockquote>
<p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html">official doc: enum</a></p>
</blockquote>
<p>枚举类的构造器必须是 private 或者 package private (也就是缺省)</p>
<blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-enum/index.html">参考: Java 语言中 Enum 类型的使用介绍</a></p>
</blockquote>
<p>从上面的定义形式来看，似乎 Java 中的枚举类型很简单，但实际上 Java 语言规范赋予枚举类型的功能非常的强大，它不仅是简单地将整形数值转换成对象，而是将枚举类型定义转变成一个完整功能的类定义。</p>
<ul>
<li>简单定义
<ul>
<li><code>public enum Color {RED, GREEN, GRAY, BLUE, YELLOW, WHITE, PURPLE, BLACK}</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>简单单例</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">enum</span> <span class="n">Tool</span><span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">INSTANCE</span><span class="o">(</span><span class="n">12</span><span class="o">);</span> 
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kt">int</span> <span class="n">num</span><span class="o">;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">Tool</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="o">.</span><span class="na">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="nf">getNum</span><span class="o">(){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用的时候
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Tool</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getNum</span><span class="o">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><a href="https://segmentfault.com/q/1010000000306839">参考: 关于java枚举类型的疑问 </a><br>
<a href="https://stackoverflow.com/questions/5551568/compilation-error-switch-with-enum">compilation-error-switch-with-enum</a></p>
</blockquote>
<hr>
<h2 id="内部类">内部类</h2>
<blockquote>
<p>可看做一种特殊的成员变量, 其特征和成员属性是一致的</p>
</blockquote>
<ul>
<li><a href="https://www.tutorialspoint.com/java/java_innerclasses.htm">https://www.tutorialspoint.com/java/java_innerclasses.htm</a></li>
<li><a href="https://www.geeksforgeeks.org/anonymous-inner-class-java/">https://www.geeksforgeeks.org/anonymous-inner-class-java/</a></li>
</ul>
<h2 id="匿名类">匿名类</h2>
<hr>
<h2 id="类型强转">类型强转</h2>
<blockquote>
<p>数学运算时,数据类型自动往大数据类型转: int float double</p>
</blockquote>
<ul>
<li>Double -&gt; int 直接(int)num;</li>
<li>int/Integer -&gt; Long 不能隐式转, 需要 Long.valueOf()</li>
</ul>
<hr>
<h2 id="时间类型">时间类型</h2>
<blockquote>
<p>java.time 包</p>
</blockquote>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html">Java8 JavaDoc: DateTimeFormatter</a><code>注意格式化中字符的准确含义</code></p>
</blockquote>
<ol>
<li>最早常用是 Date 然后 Calendar  目前Java8: Instant LocalDateTime Duration &hellip;</li>
</ol>
<h2 id="非原生类型">非原生类型</h2>
<h3 id="元组">元组</h3>
<blockquote>
<p>Groovy 中实现了一个元组系统 Tuple</p>
</blockquote>
<p>元组在语言层面, 适合应用于组合少量的多元的数据, 在多种语言中元组都是不可变的</p>
<p>优点:</p>
<ol>
<li>元组可以同时存储多种类型元素，且元素类型固定，以保证数据安全， 编译器会对赋值参数类型进行检查</li>
<li>元组的元素个数固定，不允许增加、删除，编译器会严格校验赋值参数个数</li>
<li>无需定义key，但是必要时可以为数据命名，方便数据访问</li>
<li>适合同时遍历多元数据</li>
</ol>
<p>缺点:</p>
<ol>
<li>不适合存储大量数据，因为元组不支持append、remove等方法</li>
<li>考虑到工程实际情况，后端使用的语言可能不支持元组，需要转换为其他格式</li>
</ol>
<hr>
<h1 id="运算">运算</h1>
<h2 id="除法">除法</h2>
<p>整数相除会向下取整, 浮点数相除则是正常数学运算</p>
<ul>
<li><code>3 / 2 =&gt; 1</code></li>
<li><code>3 / 2.0 =&gt; 1.5</code></li>
</ul>
<h2 id="取余">取余</h2>
<blockquote>
<p>a % b =&gt; <code>a - (a / b) * b</code></p>
</blockquote>
<p>取模运算（Modulo Operation）和取余运算（Complementation）两个概念有重叠的部分但又不完全一致。<br>
主要的区别在于对负整数进行除法运算时操作不同。取模主要是用于计算机术语中。取余则更多是数学概念。</p>
<p>对于整型数a，b来说，取模运算或者求余运算的方法都是：</p>
<ol>
<li>求整数商： c = a / b;</li>
<li>计算模或者余数： r = a - c * b.</li>
</ol>
<p>求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。</p>
<p>例如计算：-7 Mod 4 :  a = -7；b = 4；</p>
<ul>
<li>第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；</li>
<li>第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。</li>
</ul>
<p>归纳：<br>
当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。<br>
当符号不一致时，结果不一样。求模运算结果的符号和b一致，求余运算结果的符号和a一致。</p>
<p>另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。</p>
<h2 id="位运算">位运算</h2>
<blockquote>
<p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html">Bitwise and Bit Shift Operators</a></p>
</blockquote>
<p>当length是2的n次方: hash%length==hash&amp;(length-1)</p>
<hr>
<h1 id="类的结构">类的结构</h1>
<h2 id="import">import</h2>
<blockquote>
<p>import a.b.C;  import a.b.*; 的区别在于前者是完整包路径，后者是通配，但是通常编译的结果是一样的<br>
但是后者会提高编译期成本，还可能造成 同名类在不同包混淆的情况。这也是为什么后者不建议用的原因</p>
</blockquote>
<h2 id="修饰符">修饰符</h2>
<h3 id="权限修饰符">权限修饰符</h3>
<blockquote>
<p><a href="https://blog.csdn.net/yan8024/article/details/6426451">参考: java 权限修饰符</a></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">权限修饰符</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public</td>
<td style="text-align:left">任意范围</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">protected</td>
<td style="text-align:left">子类/同包</td>
<td style="text-align:left">子类是可以在任意包的</td>
</tr>
<tr>
<td style="text-align:left">package private(缺省)</td>
<td style="text-align:left">同包</td>
<td style="text-align:left">顾名思义就是包级别的private</td>
</tr>
<tr>
<td style="text-align:left">private</td>
<td style="text-align:left">当前类</td>
<td style="text-align:left">当前类级别private, 内部类从属于当前类</td>
</tr>
</tbody>
</table>
<blockquote>
<p>同包是指 <code>package xxx;</code> 语句完全一样, 而 <code>package a;</code> 与 <code>package a.b;</code> 不是同包</p>
</blockquote>
<h3 id="final">final</h3>
<blockquote>
<p><a href="https://www.baeldung.com/java-compile-time-constants">What Are Compile-Time Constants in Java</a></p>
</blockquote>
<h3 id="static">static</h3>
<h3 id="abstract">abstract</h3>
<hr>
<h2 id="成员属性">成员属性</h2>
<p>作为Java的bean, 或者大多数情况下, 属性都是私有的, 然后提供setter getter 方法,而且 一般来说, setter和getter方法是不能包含逻辑的, 也就是简单的赋值 取值
乍一看相比于C语言, 似乎这是多此一举, 但是注意面向对象思想, 一个对象对外提供的应该只是行为, 具有较强的语义性, 什么对象执行了什么方法, 而直接引用就可能将对象属性和静态属性混淆</p>
<h2 id="方法">方法</h2>
<ul>
<li>方法签名 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html">Defining Methods</a>
<ul>
<li>作用域</li>
<li>泛型列表 可选</li>
<li>返回类型</li>
<li>方法名</li>
<li>参数列表 可选</li>
<li>异常列表 可选</li>
<li>方法体</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>关于方法上参数使用 final 修饰的作用: 明确该方法内部不能对参数进行修改</li>
</ol>
</blockquote>
<h3 id="方法的传参方式">方法的传参方式</h3>
<blockquote>
<p><a href="http://www.yinwang.org/blog-cn/2016/06/08/java-value-type">Java 有值类型吗？</a><code>仅作思考</code><br>
<a href="https://juejin.im/post/5bce68226fb9a05ce46a0476">这一次，彻底解决Java的值传递和引用传递</a><code>C++ C# 都支持，C Java 仅支持值传递</code></p>
</blockquote>
<ul>
<li><code>实参</code>：方法调用前就完成初始化或为null，方法调用时传入，在Java中就是调用时被复制</li>
<li><code>形参</code>： 声明在方法参数列表内，仅在函数调用的时候进行申请内存空间，函数调用结束就释放该内存空间</li>
</ul>
<hr>
<ul>
<li><code>值类型</code>: 存储在线程栈中的数据类型，如int型, 以及对象的引用变量</li>
<li><code>引用类型</code> :存储在堆中数据的数据类型，如Date型，或自定义class对象；</li>
</ul>
<hr>
<ul>
<li><code>值传递</code>: 每次传递变量时，都是对栈里的原始值进行拷贝
<ul>
<li>如栈地址0001处存放一个整数值4，值传递时，先copy整数值4，将之存放在栈地址0002处的内存空间，再将栈地址0002作为形参传入方法；</li>
</ul>
</li>
<li><code>引用传递</code>: 每次传递变量时，直接传递栈地址，如栈地址0001处存放一个整数值4，引用传递时，直接传递栈地址0001，而不做复制。</li>
</ul>
<blockquote>
<p>总结: Java只有值传递</p>
</blockquote>
<ul>
<li>值传递  会创建副本(copy) 所以 函数无法改变实参对象的<code>值</code>(值类型)
<ul>
<li>但是如果传入的是引用类型 会复制一份地址值，就可以通过地址值更改实参对象的<code>成员属性值</code></li>
</ul>
</li>
</ul>
<p>注意 如果是 引用传递 不创建副本, 实参和形参地址是一致，所以 函数中一定可以改变原始对象</p>
<h3 id="equals">equals</h3>
<blockquote>
<p><a href="http://www.cnblogs.com/Qian123/p/5703507.html">Java提高篇——equals()与hashCode()方法详解</a>
<a href="https://www.cnblogs.com/jesonjason/p/5492208.html">参考: equals()和hashCode()区别？</a></p>
</blockquote>
<ul>
<li>Object中equals是比较内存地址， hashcode是比较散列函数的值， 后者性能更好，但是可能出现哈希碰撞</li>
<li>equals相等hashcode一定相等，equals不等 hashcode可能一致可能不一致</li>
</ul>
<blockquote>
<p>重写equals方法<br>
<a href="https://blog.csdn.net/hiroyuki/article/details/6247244">参考: 关于重写entity的equals()和hashCode()方法的必要性</a></p>
</blockquote>
<p>Double, Integer, Math, String 都是重写了equals方法， 因此比较的都是值不是内存地址</p>
<h3 id="hashcode">hashcode</h3>
<p>java.lnag.Object中对hashCode的约定：</p>
<ol>
<li>在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。</li>
<li>如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。</li>
<li>如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。</li>
</ol>
<h3 id="finalize">finalize</h3>
<hr>
<h2 id="javadoc">JavaDoc</h2>
<ul>
<li>
<p>@author</p>
</li>
<li>
<p>@version</p>
</li>
<li>
<p>@param</p>
</li>
<li>
<p>@return</p>
</li>
<li>
<p>@exception/@throws</p>
</li>
<li>
<p>@see</p>
</li>
<li>
<p>@since</p>
</li>
<li>
<p>@serial/@serialField/@serialData</p>
</li>
<li>
<p>@deprecated</p>
</li>
<li>
<p>{@link BurgersManager} 指向一个类</p>
</li>
<li>
<p>{@link BurgersManager burgers manager} 指向带有标签的类</p>
</li>
<li>
<p>{@link #eat(Burger, boolean)} 指向此类中的某个方法</p>
</li>
<li>
<p>{@link #eat(Burger, boolean) eat} 指向此类中带有标签的某个方法</p>
</li>
<li>
<p>{@link BurgersManagers#eat(Burger, boolean)} 指向其他类中的某个方法</p>
</li>
<li>
<p>{@link BurgersManagers#eat(Burger, boolean) burgers manager eat} 指向其他带有标签的类的某个方法</p>
</li>
</ul>
<hr>
<h1 id="抽象类">抽象类</h1>
<ol>
<li>Concrete and Abstract Class</li>
</ol>
<hr>
<h1 id="对象">对象</h1>
<blockquote>
<p><a href="https://www.cnblogs.com/E-star/p/10222250.html">参考: 计算Java对象内存大小</a></p>
</blockquote>
<p>多个类的继承中初始化块、静态初始化块、构造器的执行顺序为：父类静态块 ——&gt; 子类静态块 ——&gt; 父类代码块 ——&gt; 父类构造器 ——&gt; 子类代码块 ——&gt; 子类构造器</p>
<p>注意 static 静态代码块的执行是发生在该类创建对象的时候，而不是Golang和Python的init方法<code>import就会执行</code>。</p>
<hr>
<h1 id="继承和接口">继承和接口</h1>
<blockquote>
<p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/index.html">Lesson: Interfaces and Inheritance</a></p>
</blockquote>
<h2 id="常见接口">常见接口</h2>
<h3 id="serializable">Serializable</h3>
<blockquote>
<p>序列化接口</p>
</blockquote>
<ol>
<li>serialVersionUID
<ul>
<li>该属性可显式声明，若没有则编译器会 根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段</li>
<li>该属性的作用：如果显式声明且值保持一致，那么类的变动(增加或删除属性)能被兼容(改动的属性忽略或没有值))，如果没有设置则会导致反序列化异常</li>
</ul>
</li>
</ol>
<hr>
<h1 id="object">Object</h1>
<blockquote>
<p><a href="http://www.cnblogs.com/yxnchinahlj/archive/2012/02/24/2366110.html">参考:  java的(PO,VO,TO,BO,DAO,POJO)解释</a> | <a href="https://zhuanlan.zhihu.com/p/35762537?group_id=969493512006373376">VO DAO BO 等缩写的意义</a></p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox"> 原因? 场景是 类继承了一个实现了自定义接口的自定义抽象类</li>
</ul>
<p>Warning:(18, 1) java: Generating equals/hashCode implementation but without a call to superclass, even though this class does not extend java.lang.Object. If this is intentional, add &lsquo;@EqualsAndHashCode(callSuper=false)&rsquo; to your type.</p>
<h2 id="vo">VO</h2>
<blockquote>
<p>view object 前端展示对象</p>
</blockquote>
<ol>
<li>前后端分离项目中VO代表给前端展示接口使用</li>
</ol>
<hr>
<blockquote>
<p>(value object) 值对象</p>
</blockquote>
<ol>
<li>使用new关键字创建的, 由GC回收的,</li>
<li>VO是值对象, 业务对象, 存活在业务层的, 是业务逻辑使用的
<ul>
<li>它存在的目的就是为数据提供一个生存的地方</li>
</ul>
</li>
<li>VO的属性是根据当前业务的不同而不同的
<ul>
<li>也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。</li>
</ul>
</li>
</ol>
<h2 id="po">PO</h2>
<blockquote>
<p>(persistant object) 持久对象</p>
</blockquote>
<ol>
<li>PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。
<ul>
<li>并且它只能存活在一个数据库连接中，断开连接即被销毁。</li>
</ul>
</li>
<li>PO是持久化对象, 是有状态的, 每个属性代表其当前状态, 他是物理数据的对象表示
<ul>
<li>使用它能够让我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。</li>
</ul>
</li>
<li>PO的属性是跟数据库表的字段一一对应的。</li>
<li>PO对象需要实现序列化接口</li>
</ol>
<blockquote>
<p>首先说PO和VO吧，它们的关系应该是相互独立的，一个VO可以只是PO的部分，也可以是多个PO构成，同样也可以等同于一个PO（当然我是指他们的属性）。
正因为这样，PO独立出来，数据持久层也就独立出来了，它不会受到任何业务的干涉。又正因为这样，业务逻辑层也独立开来，它不会受到数据持久层的影响，业务层关心的只是业务逻辑的处理，至于怎么存怎么读交给别人吧！
不过，另外一点，如果我们没有使用数据持久层，或者说没有使用hibernate，那么PO和VO也可以是同一个东西，虽然这并不好。</p>
</blockquote>
<h2 id="to">TO</h2>
<blockquote>
<p>(transfer Object) 数据传输对象</p>
</blockquote>
<ul>
<li>在应用程序不同tie(关系)之间传输的对象</li>
<li>例如 RPC 接口中的对象 UserTO</li>
</ul>
<h2 id="bo">BO</h2>
<blockquote>
<p>(business object) 业务对象</p>
</blockquote>
<ul>
<li>从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</li>
<li>它装满了业务逻辑的处理，在业务逻辑复杂的应用中有用。</li>
</ul>
<h2 id="pojo">POJO</h2>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">Wikipedia: POJO</a> <code>Plain Old Java Object</code></p>
</blockquote>
<blockquote>
<p>(plain ordinary java object) 简单无规则java对象</p>
</blockquote>
<ul>
<li>纯的传统意义的java对象。就是说在一些Object/Relation Mapping工具中，能够做到维护数据库表记录的persisent object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java Bean，只有属性字段及setter和getter方法！</li>
</ul>
<h2 id="dao">DAO</h2>
<blockquote>
<p>(data access object) 数据访问对象</p>
</blockquote>
<ul>
<li>通常和PO结合使用，DAO中包含了各种数据库的操作方法</li>
</ul>
<hr>
<h1 id="关键字">关键字</h1>
<blockquote>
<p>Java关键字和保留字</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abstract</td>
<td style="text-align:left">class</td>
<td style="text-align:left">extends</td>
<td style="text-align:left">implements</td>
<td style="text-align:left">null</td>
<td style="text-align:left">strictfp</td>
<td style="text-align:left">true</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">assert</td>
<td style="text-align:left">const</td>
<td style="text-align:left">false</td>
<td style="text-align:left">import</td>
<td style="text-align:left">package</td>
<td style="text-align:left">super</td>
<td style="text-align:left">try</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">continue</td>
<td style="text-align:left">final</td>
<td style="text-align:left">instanceof</td>
<td style="text-align:left">private</td>
<td style="text-align:left">switch</td>
<td style="text-align:left">void</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">break</td>
<td style="text-align:left">default</td>
<td style="text-align:left">finally</td>
<td style="text-align:left">int</td>
<td style="text-align:left">protected</td>
<td style="text-align:left">synchronized</td>
<td style="text-align:left">volatile</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">do</td>
<td style="text-align:left">float</td>
<td style="text-align:left">interface</td>
<td style="text-align:left">public</td>
<td style="text-align:left">this</td>
<td style="text-align:left">while</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">case</td>
<td style="text-align:left">double</td>
<td style="text-align:left">for</td>
<td style="text-align:left">long</td>
<td style="text-align:left">return</td>
<td style="text-align:left">throw</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">catch</td>
<td style="text-align:left">else</td>
<td style="text-align:left">goto</td>
<td style="text-align:left">native</td>
<td style="text-align:left">short</td>
<td style="text-align:left">throws</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">enum</td>
<td style="text-align:left">if</td>
<td style="text-align:left">new</td>
<td style="text-align:left">static</td>
<td style="text-align:left">transient</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="try">try</h2>
<blockquote>
<p>try catch finally</p>
</blockquote>
<ul>
<li>
<p><a href="https://stackoverflow.com/questions/7143788/try-catch-finally-in-java">StackOverFlow: Try-catch-finally in java</a></p>
</li>
<li>
<p>There are at least 3 OTHER cases where the finally block is not executed:</p>
<ol>
<li>if the try block or a catch block goes into an infinite loop, or blocks for ever</li>
<li>if something (e.g. a JNI bug) causes the JVM to crash</li>
<li>if there is a machine outage (power failure, hardware error, etc).</li>
</ol>
</li>
</ul>
<h2 id="transient">transient</h2>
<blockquote>
<p>该关键字修饰的属性 在对象序列化时不参与序列化</p>
</blockquote>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Kuangcp</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-11-21
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a>
          <a href="/tags/%E8%AF%AD%E6%B3%95/">语法</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/java/advancedlearning/javagenerics/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Java泛型</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/java/ecosystem/javaboot/">
            <span class="next-text nav-default">Java快速开发框架</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/Kuangcp" class="iconfont icon-github" title="github"></a>
  <a href="https://www.kuangcp.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://gitee.com/gin9/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span>
    <span>Kuangcp</span>
    
    <br/><span><a href='http://beian.miit.gov.cn/'; target=_blank>www.kuangcp.top</a></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh-cn".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>






</body>
</html>
