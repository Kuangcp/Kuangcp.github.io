<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Linux性能分析 - Mythos · Java Developer</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Kuangcp" /><meta name="description" content="💠 Linux性能分析和管理 基准测试 运行状况信息 3.1. 分析工具 内核参数 内存情况 5.1. free 5.2. smem 性能监测 6.1. perf 6.2. top 6.3. smem 6.4. vmstat 6.5. pidstat 6.6. mpstat 6.7. iostat 6.8. ifstat 进程管理 7.1. pidof 7.2. pgrep 7.3. sar" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.99.0 with theme even" />


<link rel="canonical" href="https://www.kuangcp.top/post/linux/base/linuxperformance/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Linux性能分析" />
<meta property="og:description" content="💠 Linux性能分析和管理 基准测试 运行状况信息 3.1. 分析工具 内核参数 内存情况 5.1. free 5.2. smem 性能监测 6.1. perf 6.2. top 6.3. smem 6.4. vmstat 6.5. pidstat 6.6. mpstat 6.7. iostat 6.8. ifstat 进程管理 7.1. pidof 7.2. pgrep 7.3. sar" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.kuangcp.top/post/linux/base/linuxperformance/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2018-12-15T11:16:27+00:00" />
<meta property="article:modified_time" content="2018-12-15T11:16:27+00:00" />

<meta itemprop="name" content="Linux性能分析">
<meta itemprop="description" content="💠 Linux性能分析和管理 基准测试 运行状况信息 3.1. 分析工具 内核参数 内存情况 5.1. free 5.2. smem 性能监测 6.1. perf 6.2. top 6.3. smem 6.4. vmstat 6.5. pidstat 6.6. mpstat 6.7. iostat 6.8. ifstat 进程管理 7.1. pidof 7.2. pgrep 7.3. sar"><meta itemprop="datePublished" content="2018-12-15T11:16:27+00:00" />
<meta itemprop="dateModified" content="2018-12-15T11:16:27+00:00" />
<meta itemprop="wordCount" content="8278">
<meta itemprop="keywords" content="基础," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux性能分析"/>
<meta name="twitter:description" content="💠 Linux性能分析和管理 基准测试 运行状况信息 3.1. 分析工具 内核参数 内存情况 5.1. free 5.2. smem 性能监测 6.1. perf 6.2. top 6.3. smem 6.4. vmstat 6.5. pidstat 6.6. mpstat 6.7. iostat 6.8. ifstat 进程管理 7.1. pidof 7.2. pgrep 7.3. sar"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Mythos</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Mythos</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Linux性能分析</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-12-15 </span>
        <div class="post-category">
            <a href="/categories/linux/"> Linux </a>
            </div>
          <span class="more-meta"> 约 8278 字 </span>
          <span class="more-meta"> 预计阅读 17 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#linux性能分析和管理">Linux性能分析和管理</a></li>
    <li><a href="#基准测试">基准测试</a></li>
    <li><a href="#运行状况信息">运行状况信息</a>
      <ul>
        <li><a href="#分析工具">分析工具</a></li>
      </ul>
    </li>
    <li><a href="#内核参数">内核参数</a></li>
    <li><a href="#内存情况">内存情况</a>
      <ul>
        <li><a href="#free">free</a></li>
        <li><a href="#smem">smem</a></li>
      </ul>
    </li>
    <li><a href="#性能监测">性能监测</a>
      <ul>
        <li><a href="#perf">perf</a></li>
        <li><a href="#top">top</a></li>
        <li><a href="#smem-1">smem</a></li>
        <li><a href="#vmstat">vmstat</a></li>
        <li><a href="#pidstat">pidstat</a></li>
        <li><a href="#mpstat">mpstat</a></li>
        <li><a href="#iostat">iostat</a></li>
        <li><a href="#ifstat">ifstat</a></li>
      </ul>
    </li>
    <li><a href="#进程管理">进程管理</a>
      <ul>
        <li><a href="#pidof">pidof</a></li>
        <li><a href="#pgrep">pgrep</a></li>
        <li><a href="#sar">sar</a></li>
        <li><a href="#lsof">lsof</a>
          <ul>
            <li><a href="#删除文件">删除文件</a></li>
          </ul>
        </li>
        <li><a href="#fuser">fuser</a></li>
        <li><a href="#ps">ps</a>
          <ul>
            <li><a href="#procs">procs</a></li>
            <li><a href="#pstree">pstree</a></li>
          </ul>
        </li>
        <li><a href="#kill">kill</a>
          <ul>
            <li><a href="#killall">killall</a></li>
          </ul>
        </li>
        <li><a href="#trap">trap</a></li>
        <li><a href="#作业控制">作业控制</a></li>
        <li><a href="#守护进程">守护进程</a>
          <ul>
            <li><a href="#nohup">nohup</a></li>
            <li><a href="#disown">disown</a></li>
            <li><a href="#setid">setid</a></li>
            <li><a href="#screen">screen</a></li>
          </ul>
        </li>
        <li><a href="#ipc">IPC</a></li>
      </ul>
    </li>
    <li><a href="#系统管理">系统管理</a>
      <ul>
        <li><a href="#uname">uname</a></li>
        <li><a href="#who">who</a></li>
        <li><a href="#service">service</a></li>
        <li><a href="#chkconfig">chkconfig</a></li>
        <li><a href="#dmidecode">dmidecode</a></li>
        <li><a href="#lsmod">lsmod</a></li>
        <li><a href="#chroot">chroot</a></li>
      </ul>
    </li>
    <li><a href="#关机重启">关机/重启</a></li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注意】最后更新于 <span class="timeago" datetime="2018-12-15T11:16:27" title="December 15, 2018">December 15, 2018</span>，文中内容可能已过时，请谨慎使用。</p>
    </div>
  </div>
    <div class="post-content">
      <p>💠</p>
<ul>
<li>
<ol>
<li><a href="#linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%A1%E7%90%86">Linux性能分析和管理</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">基准测试</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="#%E8%BF%90%E8%A1%8C%E7%8A%B6%E5%86%B5%E4%BF%A1%E6%81%AF">运行状况信息</a></li>
</ol>
<ul>
<li>3.1. <a href="#%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7">分析工具</a></li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0">内核参数</a></li>
</ol>
</li>
<li>
<ol start="5">
<li><a href="#%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5">内存情况</a></li>
</ol>
<ul>
<li>5.1. <a href="#free">free</a></li>
<li>5.2. <a href="#smem">smem</a></li>
</ul>
</li>
<li>
<ol start="6">
<li><a href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B">性能监测</a></li>
</ol>
<ul>
<li>6.1. <a href="#perf">perf</a></li>
<li>6.2. <a href="#top">top</a></li>
<li>6.3. <a href="#smem">smem</a></li>
<li>6.4. <a href="#vmstat">vmstat</a></li>
<li>6.5. <a href="#pidstat">pidstat</a></li>
<li>6.6. <a href="#mpstat">mpstat</a></li>
<li>6.7. <a href="#iostat">iostat</a></li>
<li>6.8. <a href="#ifstat">ifstat</a></li>
</ul>
</li>
<li>
<ol start="7">
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">进程管理</a></li>
</ol>
<ul>
<li>7.1. <a href="#pidof">pidof</a></li>
<li>7.2. <a href="#pgrep">pgrep</a></li>
<li>7.3. <a href="#sar">sar</a></li>
<li>7.4. <a href="#lsof">lsof</a>
<ul>
<li>7.4.1. <a href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6">删除文件</a></li>
</ul>
</li>
<li>7.5. <a href="#fuser">fuser</a></li>
<li>7.6. <a href="#ps">ps</a>
<ul>
<li>7.6.1. <a href="#procs">procs</a></li>
<li>7.6.2. <a href="#pstree">pstree</a></li>
</ul>
</li>
<li>7.7. <a href="#kill">kill</a>
<ul>
<li>7.7.1. <a href="#killall">killall</a></li>
</ul>
</li>
<li>7.8. <a href="#trap">trap</a></li>
<li>7.9. <a href="#%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6">作业控制</a></li>
<li>7.10. <a href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>
<ul>
<li>7.10.1. <a href="#nohup">nohup</a></li>
<li>7.10.2. <a href="#disown">disown</a></li>
<li>7.10.3. <a href="#setid">setid</a></li>
<li>7.10.4. <a href="#screen">screen</a></li>
</ul>
</li>
<li>7.11. <a href="#ipc">IPC</a></li>
</ul>
</li>
<li>
<ol start="8">
<li><a href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86">系统管理</a></li>
</ol>
<ul>
<li>8.1. <a href="#uname">uname</a></li>
<li>8.2. <a href="#who">who</a></li>
<li>8.3. <a href="#service">service</a></li>
<li>8.4. <a href="#chkconfig">chkconfig</a></li>
<li>8.5. <a href="#dmidecode">dmidecode</a></li>
<li>8.6. <a href="#lsmod">lsmod</a></li>
<li>8.7. <a href="#chroot">chroot</a></li>
</ul>
</li>
<li>
<ol start="9">
<li><a href="#%E5%85%B3%E6%9C%BA%E9%87%8D%E5%90%AF">关机/重启</a></li>
</ol>
</li>
</ul>
<p>💠 2024-10-09 16:33:39</p>
<hr>
<h1 id="linux性能分析和管理">Linux性能分析和管理</h1>
<h1 id="基准测试">基准测试</h1>
<p>目的：通过一致的工具及配置，跑不同的测试工具，看性能表现，对比不同设备间性能差异</p>
<blockquote>
<p><a href="https://blog.csdn.net/gatieme/article/details/54296440">几款优秀的Linux基准测试工具</a><br>
<a href="https://wiki.archlinux.org/title/Improving_performance">Arch wiki: Improving performance</a></p>
</blockquote>
<ol>
<li><a href="https://github.com/kdlucas/byte-unixbench">byte-unixbench</a></li>
<li><a href="https://www.geekbench.com">geekbench</a></li>
</ol>
<blockquote>
<p>高负载测试</p>
</blockquote>
<ol>
<li><a href="https://github.com/cirocosta/stress">stress</a></li>
<li><a href="https://github.com/ColinIanKing/stress-ng">stress-ng</a></li>
</ol>
<ul>
<li>stress-ng &ndash;cpu 16 &ndash;timeout 180 <code>占满CPU</code></li>
<li>stress-ng &ndash;vm 4 &ndash;vm-bytes 10G &ndash;vm-hang 180 &ndash;timeout 180s</li>
<li>stress-ng &ndash;hdd 5 &ndash;hdd-bytes 10G &ndash;timeout 180s</li>
</ul>
<blockquote>
<p>简易评测</p>
</blockquote>
<ul>
<li>单核CPU: <code>time echo &quot;scale=9000; 4*a(1)&quot; | bc -l -q</code></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">设备</th>
<th style="text-align:left">耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Mac Book Pro 2023 32G:</td>
<td style="text-align:left"><strong>4s</strong></td>
</tr>
<tr>
<td style="text-align:left">i5-10400F CPU @ 2.90GHz:</td>
<td style="text-align:left"><strong>60s</strong></td>
</tr>
<tr>
<td style="text-align:left">笔记本 AMD Ryzen 7 6800H:</td>
<td style="text-align:left"><strong>59s</strong></td>
</tr>
<tr>
<td style="text-align:left">阿里云99年费双核服务器 2.5GHz</td>
<td style="text-align:left"><strong>79s</strong></td>
</tr>
<tr>
<td style="text-align:left">Redmi K60</td>
<td style="text-align:left"><strong>57s</strong></td>
</tr>
<tr>
<td style="text-align:left">AMD 3700X 8-Core @ 16x 3.6GHz</td>
<td style="text-align:left"><strong>53s</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>3700x 和 10400F 和 K60 的 8+ Gen 1 单核性能是差不多的 😅</p>
</blockquote>
<hr>
<h1 id="运行状况信息">运行状况信息</h1>
<blockquote>
<p>系统实时状态信息</p>
</blockquote>
<ul>
<li>
<p>top</p>
</li>
<li>
<p><a href="https://github.com/hishamhm/htop">htop</a><code>Htop更好用</code></p>
<ul>
<li><a href="https://medium.com/starbugs/do-you-understand-htop-ffb72b3d5629">你一定用過 htop，但你有看懂每個欄位嗎？</a></li>
<li>CPU: Task 进程 thr 线程 kthr 内核线程 running 执行中的线程</li>
</ul>
</li>
<li>
<p>gotop</p>
</li>
<li>
<p>ytop</p>
</li>
<li>
<p>ctop</p>
</li>
<li>
<p><a href="https://github.com/nicolargo/glances">Glances</a> <code>信息全面 资源消耗大些</code></p>
</li>
<li>
<p>nmon</p>
</li>
<li>
<p><code>uptime </code> 执行结果</p>
<ul>
<li>系统当前时间 | 主机已运行时间 | 用户连接数 | 1,5,15,分钟的系统平均负载</li>
</ul>
</li>
<li>
<p><code>cat /proc/loadavg </code></p>
<ul>
<li>运行结果 : 1,5,15分钟的平均负载 | 当前运行的进程/总进程 | 最近一个启动的进程的id</li>
</ul>
</li>
</ul>
<blockquote>
<p>常规: 单核:平均负载0.7以下是安全的,大于就需要优化了,多核则是 0.7*N(核心数)<br>
<a href="http://www.penglixun.com/tech/system/how_to_calc_load_cpu.html">从源码看Load计算方式</a></p>
</blockquote>
<ul>
<li><code>lm-sensors</code> CPU等硬件温度等信息检测 <a href="https://www.ostechnix.com/view-cpu-temperature-linux/">参考</a></li>
</ul>
<h2 id="分析工具">分析工具</h2>
<blockquote>
<p><a href="https://github.com/Netflix/vector">vector</a>
<a href="http://x0rg.github.io/CPU-X/">CPU-X </a> | <a href="https://github.com/X0rg/CPU-X">Github:repo</a><code>简洁而详细</code></p>
</blockquote>
<hr>
<h1 id="内核参数">内核参数</h1>
<ul>
<li>sysctl -n name 读取配置</li>
<li>sysctl -w name value 写入配置</li>
<li>sysctl -p 不重启的情况下reload配置</li>
</ul>
<hr>
<h1 id="内存情况">内存情况</h1>
<h2 id="free">free</h2>
<ul>
<li>直接运行得到的就是内存情况,默认是kb为单位,可以指定 -b -m -g (后两种不推荐,因为向下取整的特性)
<ul>
<li>-h 人类可读形式 推荐,能快速看到大略,精准的话还是用 -b</li>
</ul>
</li>
</ul>
<p><strong><code>输出解析</code></strong></p>
<ul>
<li><code>used</code> 内存已使用量(不含buff/cache), <code>free</code> 空闲内存, <code>available</code> 可用内存</li>
<li>buffers,cached:
<ul>
<li><code>buffers</code> 是为了写时,解决内存和硬盘巨大速度差存在的缓冲区(块设备IO相关的缓存页)</li>
<li><code>cache</code> 是为了读时,为了尽量减少内存从硬盘读数据的次数,缓冲区(普通文件相关的缓存页)</li>
<li><code>cached</code> 就是cache内存区域已经使用量</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>注意: 如果是新版的free, shared 那一栏总是为0, 因为shared本就是说明进程共享内存容量, free认为不能显示数有效信息, 就抛弃了这个指标,总是显示为0</li>
</ul>
</blockquote>
<h2 id="smem">smem</h2>
<p>较精准展示进程使用的内存和swap内存</p>
<hr>
<h1 id="性能监测">性能监测</h1>
<blockquote>
<p>通过各类软件的输出，快速定位问题点</p>
</blockquote>
<ol>
<li>监测CPU利用率 top,sysstat,mpstat,iostat,sar</li>
</ol>
<p>sysstat软件包：sysstat，mpstat vmstat iostat</p>
<hr>
<blockquote>
<p>工程化管理多个Linux主机</p>
</blockquote>
<p><a href="https://github.com/tianshiyeben/wgcloud">wgcloud</a><br>
<a href="https://github.com/netdata/netdata">netdata</a></p>
<h2 id="perf">perf</h2>
<blockquote>
<p><a href="https://yoc.docs.t-head.cn/linuxbook/Chapter4/perf.html">参考: Perf 使用说明</a></p>
</blockquote>
<blockquote>
<p>arch: yay linux-tools 选择 perf 进行安装</p>
</blockquote>
<blockquote>
<p><a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a>  <code>结合使用</code></p>
</blockquote>
<h2 id="top">top</h2>
<blockquote>
<p>来源 procps, 用于查看 进程详细信息, CPU占用率 内存 网络等&hellip;</p>
</blockquote>
<h2 id="smem-1">smem</h2>
<blockquote>
<p>Report memory usage with shared memory divided proportionally.</p>
</blockquote>
<h2 id="vmstat">vmstat</h2>
<blockquote>
<p>Report virtual memory statistics</p>
</blockquote>
<ul>
<li>
<p>最初是设计为查看虚拟内存的,现在常用于性能监测</p>
</li>
<li>
<p><code>vmstat 1 4</code> 输出信息,间隔1s 共4次 特别注意第一行数据是指开机以来的平均值,后面的才是当前值</p>
<ul>
<li>procs 区域:
<ul>
<li>r 进程运行队列中的进程个数</li>
<li>b 处于不可中断的睡眠状态的进程个数</li>
</ul>
</li>
<li>memory 区域:
<ul>
<li>swpd 虚拟内存使用量</li>
<li>free 空闲内存,不含buffer cache</li>
<li>buff</li>
<li>cache</li>
</ul>
</li>
<li>swap 区域:
<ul>
<li>si 每秒从交换分区写入内存的量</li>
<li>so 每秒从内存写入交换分区的量</li>
</ul>
</li>
<li>io 区域:
<ul>
<li>bi 每秒从块设备读取的块数量</li>
<li>bo 每秒向块设备写入的块数量</li>
</ul>
</li>
<li>system 区域:
<ul>
<li>in 每秒中断数(含时钟中断)</li>
<li>cs 每秒上下文切换次数 context switch</li>
</ul>
</li>
<li>cpu 区域:
<ul>
<li>us 用户进程 cpu消耗时间百分比</li>
<li>sy 内核进程 cpu消耗百分比</li>
<li>id cpu空闲状态时间百分比</li>
<li>wa IO等待消耗时间百分比</li>
<li>st 虚拟管理程序占用时间百分比</li>
</ul>
</li>
</ul>
</li>
<li>
<p>更多参数用法:</p>
<ul>
<li><code>-a</code> 输出中,原来的 buff 和cache 被 inact 和 active 取代了
<ul>
<li>inact (inactive memory) 非活跃内存, 一段时间没有使用的内存(优先置换到交换分区的内存)</li>
<li>active 活跃内存, 正在被使用的内存</li>
</ul>
</li>
<li><code>-f</code> 查看启动以来创建的fork(或者称为task)总数</li>
<li><code>-m</code> 展示内存 slabinfo</li>
<li><code>-s</code> 展示内存指标以及系统事件</li>
<li><code>-d</code> 展示各磁盘的统计信息</li>
<li><code>-p /dev/sda1</code> 展示某一特定分区的 IO信息</li>
</ul>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p135.jpg" alt="p135"></p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p136.jpg" alt="p136"></p>
</li>
</ul>
<blockquote>
<p>但是数值大一点就会列错位，可以用column来格式化 <code>vmstat  1 5 | column -t</code> 但是等到执行完了才能看到结果，此时可以输出到文件里，看的时候格式化
<code>vmstat  4 &gt; run.log &amp;</code> 然后 <code>less run.log | column -t</code> . 或者 <code>watch 'tail -n 20 run.log| column -t '</code></p>
</blockquote>
<blockquote>
<p>安装： apk add procps， pacman -S procps-ng</p>
</blockquote>
<h2 id="pidstat">pidstat</h2>
<blockquote>
<p>Report statistics for Linux tasks.</p>
</blockquote>
<ul>
<li>当使用vmstat发现cs值很高时可以查看是哪些进程引起的 <code>pidstat -w 5</code></li>
</ul>
<h2 id="mpstat">mpstat</h2>
<blockquote>
<p>对多处理器的统计</p>
</blockquote>
<ul>
<li><code>mpstat -P ALL 1 1</code> 查询所有CPU信息,后两个参数是和vmstat一样的, <code>如果只看0号CPU 就ALL改成0即可</code>
<ul>
<li>运行结果:
<ul>
<li>%user 用户进程 %</li>
<li>%nice 进程降级时CPU %</li>
<li>%sys 内核进程 %</li>
<li>%iowait 等待IO的CPU时间 %</li>
<li>%irq 处理系统中断 %</li>
<li>%soft 软件中断 %</li>
<li>%steal 虚机管理程序占用的 CPU %</li>
<li>%guest 运行虚拟处理器占用的CPU %</li>
<li>%idle CPU空闲时间</li>
</ul>
</li>
</ul>
</li>
<li>参数
<ul>
<li><code>-I </code> 值可选, SUM CPU ALL</li>
<li>分别表示 CPU总的中断数, 展示每一个CPU的中断数 SUM和CPU数据综合展示</li>
</ul>
</li>
</ul>
<h2 id="iostat">iostat</h2>
<ul>
<li>
<p>执行<code>iostat</code>输出信息:</p>
<ul>
<li>第一部分, 系统信息</li>
<li>第二部分, CPU信息</li>
<li>第三部分, 磁盘信息</li>
</ul>
</li>
<li>
<p>参数:</p>
<ul>
<li>-d 只显示磁盘信息,不显示CPU信息</li>
<li>-k 统计使用KB为单位</li>
<li>最后两个数值参数和vmstat一样 例如<code>iostat -d -k 1 3</code></li>
<li>输出结果:
<ul>
<li>tps: 每秒进程的IO读写请求总数</li>
<li>KB_read/s, KB_wrtn/s 每秒读取,写入的字节数单位KB</li>
<li>KB_read, KB_wrtn 写入读取的总数</li>
</ul>
</li>
<li>同样的, 第一行数据是系统启动到现在的统计结果 <code>-y</code> 可以去除第一行</li>
<li>-x 显示更多信息</li>
</ul>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p162.jpg" alt="p162"></p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p163.jpg" alt="p163"></p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p164.jpg" alt="p164"></p>
</li>
</ul>
<hr>
<h2 id="ifstat">ifstat</h2>
<blockquote>
<p>handy utility to read network interface statistics</p>
</blockquote>
<ul>
<li>-a 全部统计信息</li>
<li>-t sec 过去时间内流量信息</li>
</ul>
<hr>
<h1 id="进程管理">进程管理</h1>
<blockquote>
<p>按程序名字找到id <code>ps -ef | grep &quot;$NAME&quot; | grep -v &quot;grep&quot; | awk '{print $2}'</code></p>
</blockquote>
<h2 id="pidof">pidof</h2>
<blockquote>
<p>find the process ID of a running program</p>
</blockquote>
<ul>
<li>查询ssh服务启动的进程的pid <code>pidof sshd</code></li>
<li>找出shell脚本执行的pid, <code>pidof -x 脚本文件名</code></li>
<li>-s 只显示一个pid, 有的软件会有多个进程,就有多个pid</li>
<li>忽略指定的pid <code>-o pid</code></li>
<li><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p167.jpg" alt="p167"></li>
</ul>
<h2 id="pgrep">pgrep</h2>
<blockquote>
<p>pgrep, pkill - look up or signal processes based on name and other attributes</p>
</blockquote>
<ol>
<li>pgrep java 查看Java <code>进程</code></li>
</ol>
<h2 id="sar">sar</h2>
<blockquote>
<p>Collect, report, or save system activity information.</p>
</blockquote>
<p><strong>需要安装和启动 sysstat 服务 才能使用</strong></p>
<blockquote>
<p><a href="https://sourceforge.net/projects/ksar/">ksar</a></p>
</blockquote>
<ul>
<li>
<p>默认持续执行除非Ctrl C退出,指定参数后就和vmstat一样 <code>sar 2 3</code></p>
</li>
<li>
<p>输出到指定文件中: <code>-o filename</code> 注意这个不是文本结构,是特殊的结构化方式, 查看需要 <code>sar -f filename</code></p>
</li>
<li>
<p>多核的支持:<code>sar -P ALL 1 1 </code> 与mpstat 大致相同</p>
</li>
<li>
<p>指定结束时间 <code>-e 18:00:00</code> 一般和 -o -f一起用</p>
<ul>
<li>搭配 -o 指定存储结束的时间点</li>
<li>搭配 -f 指定从文件读取的数据的结束时间点</li>
</ul>
</li>
<li>
<p>查看网络信息 -n 参数有: DEV EDEV SOCK FULL</p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p172.jpg" alt="p172"></p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p173.jpg" alt="p173"></p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p174.jpg" alt="p174"></p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p175.jpg" alt="p175"></p>
</li>
<li>
<p><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p176.jpg" alt="p176"></p>
</li>
</ul>
<h2 id="lsof">lsof</h2>
<blockquote>
<p>list open files<br>
这个命令使用时最好使用sudo或者root用户, 不然就会提示因权限问题导致显示信息不全</p>
</blockquote>
<ol>
<li><code>lsof -d 3</code> 查看打开标准错误输出的进程 (标准错误输出是3) <code>正在报错的进程</code></li>
<li><code>lsof file/dir</code> 查看打开某文件或目录(不关注子文件夹)的进程</li>
<li><code>sudo lsof -p pid</code> <strong>通过进程查询打开的fd</strong></li>
<li><code>sudo lsof -u username</code> 查看某一用户打开的文件 输出结果说明:
<ul>
<li>Command 进程名过长会简略显示, PID 进程标识符, USER 进程拥有者</li>
<li>FD 一般是文件描述符:
<ul>
<li>两类: 一.文件描述符,二.描述文件特征的标识</li>
<li>第一类:
<ul>
<li>0 表示标准输入, 1 标准输出, 2 标准错误输出, n 其他文件描述符</li>
</ul>
</li>
<li>第二类:
<ul>
<li>cwd 应用程序的当前工作目录</li>
<li>txt 程序代码或是数据</li>
<li>mem 内存映射文件</li>
<li>pd 父目录</li>
<li>rtd 根目录</li>
<li>DEL 文件已经被进程删除, 但是还在内存中存在</li>
</ul>
</li>
</ul>
</li>
<li>TYPE 文件类型:
<ul>
<li>DIR 目录, REG 普通文件, CHR 字符类型, BLK 块设备</li>
<li>UNIX unix域套接字</li>
<li>FIFO 先进先出 pipe队列</li>
<li>IPv4/Ipv6 网络socket</li>
</ul>
</li>
<li>DEVICE 磁盘的名称, SIZE 文件大小, NODE 索引节点(文件在磁盘上的标识), NAME 打开文件的确切名字</li>
</ul>
</li>
</ol>
<blockquote>
<p>socket使用情况</p>
</blockquote>
<p><code>lsof -Pni</code> 列出所有socket和 <code>netstat -pant</code> 类似
<code>lsof -i [4/6] [protocol][@hostname|hostaddr] [:service|port]</code>  按条件列出所有socket</p>
<ul>
<li>4/6 IPv4/Ipv6</li>
<li>protocol TCP/UDP 缺省TCP</li>
<li>:service 服务名 可以多个 逗号分隔</li>
<li>:port 端口 可以多个 逗号分隔</li>
</ul>
<hr>
<ul>
<li><code>lsof -i -a -p pid</code> 列出指定进程打开的socket</li>
<li><code>lsof +L1</code> 查看 已删除 但是<strong>未被回收磁盘空间的文件</strong>见下文删除文件</li>
</ul>
<h3 id="删除文件">删除文件</h3>
<blockquote>
<p>真正删除文件</p>
</blockquote>
<ul>
<li>创建一个0填充的1g文件 <code>dd if=/dev/zero bs=1024 count=1000000 of=./1gb.file</code>
<ul>
<li>就能看到硬盘的被占用了1GB <code>df -h</code></li>
</ul>
</li>
<li>然后用一个简单的程序一直占用他, 例如 less
<ul>
<li>删除<code>rm -f 1gb.file</code> 再 ls 下能发现文件不见了, 但是对硬盘的占用还在</li>
<li>原因就是,Linux系统中, rm命令删除文件实际上只是减少文件的link数, 当link数为0时,文件才会被删掉。</li>
<li>当进程打开某文件,该文件link就加1, 因为脚本一直占用着文件, 所以删除没有看到硬盘的占用下降,只是目录中找不到该文件而已</li>
</ul>
</li>
<li><code>lsof | grep 1gb.file</code>或者 <code>lsof 1gb.file</code> 就能找到占用该文件的进程了,杀掉就能真正的删除文件了
<ul>
<li>可以试试两个多个Python脚本同时占用, 那要将进程全部杀掉,才有用</li>
</ul>
</li>
</ul>
<blockquote>
<p>恢复删除的文件 (前提是仍被其他进程引用)</p>
</blockquote>
<ol>
<li>echo &ldquo;1 2 3&rdquo; &raquo; test.log</li>
<li>less test.log <code>打开后不退出</code></li>
<li>rm test.log</li>
<li>sudo lsof | grep test.log <code>找出持有该文件的进程id</code>
<blockquote>
<p>less      12008                    kcp    4r      REG                8,3        40239    4990940 /home/kcp/test/test.log (deleted)</p>
</blockquote>
</li>
<li>ls -l /proc/12008/fd/ <code>查询持有的文件,找到对应的数字软链接,这里找到的是4</code></li>
<li>cp /proc/12008/fd/4 test.log.save <code>复制回来</code></li>
</ol>
<h2 id="fuser">fuser</h2>
<blockquote>
<p>identify processes using files or sockets<br>
和 lsof 功能差不多,但 fuser 是符合 POSIX 标准的命令 (POSIX:可移植操作系统接口)</p>
</blockquote>
<ul>
<li><code>fuser -v /path/to/sdk</code> 列出正在打开这个目录的进程(和lsof一样不关注子文件夹)</li>
<li>输出信息 详解:
<ul>
<li>USER 用户, PID 进程号, COMMAND 程序名</li>
<li>ACCESS 访问关系:
<ul>
<li>c 作为当前目录使用， e 作为可执行对象使用， r 作为根目录使用， s 作为共享库或其他装载对象 使用</li>
<li>m 作为映射文件或共享库使用，  f 打开文件, 默认不显示， F 打开文件,用于写操作 默认不显示</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>常用选项</code></p>
<ol>
<li>-a 显示所有命令行中指定的文件，默认情况下被访问的文件才会被显示。</li>
<li>-c 和-m一样，用于POSIX兼容。</li>
<li>-k 杀掉访问文件的进程。如果没有指定-signal就会发送SIGKILL信号。</li>
<li>-i 杀掉进程之前询问用户，如果没有-k这个选项会被忽略。</li>
<li>-l 列出所有已知的信号名称。</li>
<li>-m name 指定一个挂载文件系统上的文件或者被挂载的块设备（名称name）
<ul>
<li>所有访问这个文件或者文件系统的进程都会被列出来。</li>
<li>如果指定的是一个目录会自动转换成&quot;name/&quot;,并使用所有挂载在那个目录下面的文件系统。</li>
</ul>
</li>
<li>-n space 指定一个不同的命名空间(space).这里支持不同的空间文件(文件名，此处默认)、tcp(本地tcp端口)、udp(本地udp端口)。
<ul>
<li>对于端口， 可以指定端口号或者名称，如果不会引起歧义那么可以使用简单表示的形式</li>
<li>例如：name/space (即形如:80/tcp之类的表示)。</li>
</ul>
</li>
<li>-s 静默模式，这时候-u,-v会被忽略。-a不能和-s一起使用。</li>
<li>-signal 使用指定的信号，而不是用SIGKILL来杀掉进程。可以通过名称或者号码来表示信号(例如-HUP,-1),这个选项要和-k一起使用，否则会被忽略。</li>
<li>-u 在每个PID后面添加进程拥有者的用户名称。</li>
<li>-v 详细模式。输出似ps命令的输出，包含PID,USER,COMMAND等许多域,如果是内核访问的那么PID为kernel. -V 输出版本号。</li>
<li>-4 使用IPV4套接字,不能和-6一起应用，只在-n的tcp和udp的命名存在时不被忽略。</li>
<li>-6 使用IPV6套接字,不能和-4一起应用，只在-n的tcp和udp的命名存在时不被忽略。</li>
<li><code>-</code> 重置所有的选项，把信号设置为SIGKILL.</li>
</ol>
<ul>
<li>查询占用端口 <code>fuser -v -n tcp 22</code> 或者 <code>fuser -v 22/tcp</code> fuser中含三种协议： file 默认, tcp, udp
<ul>
<li>得到一些进程信息 <code>fuser -v -n tcp 0</code></li>
</ul>
</li>
<li>发送信号量 <code>fuser -v -k /home/kuang/sdk</code> 会把占用该文件夹的进程全部杀掉 (如果是ssh登录的服务器,当前目录就是这个的话, 会掉线)</li>
</ul>
<h2 id="ps">ps</h2>
<blockquote>
<p><a href="http://www.cnblogs.com/lidabo/p/5505610.html">参考: ps命令输出</a> <code>输出的信息解释</code></p>
</blockquote>
<ul>
<li>
<p>直接运行 <code>ps</code> 就会显示当前会话中的进程</p>
</li>
<li>
<p><code>ps aux</code> 显示系统中所有进程的状态信息 <code>可根据需要自由组合</code></p>
<ul>
<li>a 显示各终端(会话)上的所有进程, u 会展示进程所属用户, x 对于没有关联到终端运行的进程也展示出来</li>
<li>输出列
<ul>
<li>VSZ</li>
<li>RSS</li>
<li>STAT
<ul>
<li><code>D</code> 无法中断的休眠状态（通常 IO 的进程）；</li>
<li><code>R</code> 正在运行可中在队列中可过行的；</li>
<li><code>S</code> 处于休眠状态；</li>
<li><code>T</code> 停止或被追踪；</li>
<li><code>W</code> 进入内存交换 （从内核2.6开始无效）；</li>
<li><code>X</code> 死掉的进程 （基本很少见）；</li>
<li><code>Z</code> 僵尸进程；</li>
<li><code>&lt;</code> 优先级高的进程</li>
<li><code>N</code> 优先级较低的进程</li>
<li><code>L</code> 有些页被锁进内存；</li>
<li><code>s</code> 进程的领导者（在它之下有子进程）；</li>
<li><code>l</code> 多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）；</li>
<li><code>+</code> 位于后台的进程组；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>ps aux</code>和<code>ps -aux</code>的区别:</p>
<ul>
<li>虽然执行结果看起来是一模一样的, 但是 <code>ps -aux </code> 其实应该理解为 <code>ps -a -u x</code> 显示用户名为 x 的用户的所有进程</li>
<li>当 x 用户不存在时ps就将其理解为 <code>ps aux</code></li>
<li>原因,因为他的三种格式:  BSD 选项前 不加短横线 <code>ps aux</code>  UNIX 选项前 加短横线 <code>ps -aux </code>  GNU 选项前 加双短横线  <code>ps --format</code></li>
<li>BSD格式的 <code>ps aux</code> 等价于 <code>ps -eF</code>  e 显示全部进程, 包含了未在终端运行的进程 F 显示详尽的进程信息</li>
<li>Debian 上 <code>ps -ef</code> 和 <code>ps ef</code> 执行效果不一样</li>
</ul>
</li>
<li>
<p><code>-o</code> 输出指定列 <code>ps -eo pid,user,cmd,start ... </code> 更多需要查看手册 <code>man ps</code></p>
<ul>
<li><a href="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p200.jpg">p200</a></li>
<li>查看进程启动日期，时间，时间差 <code>ps -eo pid,start,lstart,%cpu,start_time,etime,cmd</code></li>
</ul>
</li>
<li>
<p>对范围进行筛选</p>
<ul>
<li>根据用户 <code>ps -u root</code></li>
<li><code>ps -U root -u root u</code>
<ul>
<li>-U 实际用户 RUID</li>
<li>-u 有效用户 EUID</li>
<li>u 按用户名和进程号的顺序来显示进程, 多列构成</li>
</ul>
</li>
<li>根据命令名称查找pid <code>ps -C sshd</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>排序 :</p>
</blockquote>
<ul>
<li><code>ps aux --sort -pcpu/+pcpu/</code> 按CPU使用率,进行降序/升序排列</li>
<li>多个条件 <code>--sort=+pcpu, -pmem</code> CPU升序,内存降序排列</li>
</ul>
<blockquote>
<p>查询线程信息:</p>
</blockquote>
<ul>
<li><code>ps -ef | grep mysql</code></li>
<li><code>ps -L pid</code> 显示某id的线程的具体信息 其中的LWP (轻量级进程, 可以理解为用户进程) Light Weight Process
<ul>
<li><code>ps aux -L</code> 查看全部线程</li>
</ul>
</li>
<li><code>ps -T pid</code> 显示 将-L的LWP替换为SPID (系统中的线程ID)</li>
<li>查看进程下的线程 <code>ps huH p pid</code></li>
</ul>
<blockquote>
<p>进程树:</p>
</blockquote>
<ul>
<li>BSD格式 : <code>ps axjf</code> a 所有进程 x 显示没有控制终端的进程 j 任务格式显示进程  f ascaii字符显示树状结果</li>
<li>UNIX : <code>ps -ejH</code> e 显示所有进程  j 任务格式来显示进程  H 显示数状结构</li>
</ul>
<p><strong>实践</strong></p>
<ol>
<li>
<p>列出Java进程 <code>ps aux | grep RSS | grep -v &quot;grep&quot; &amp;&amp; ps aux | egrep -v &quot;grep&quot; | grep -i java</code></p>
</li>
<li>
<p>统计所有Java进程的内存 <code>ps aux | grep java | grep -v grep | awk '{sum+=$6};END {print sum &quot;K &quot; sum/1024&quot;M &quot;}'</code></p>
<ul>
<li><code>ps -a -x -o rss,comm | grep java | awk '{sum+=$1};END {print sum &quot;K &quot; sum/1024&quot;M &quot;}'</code></li>
</ul>
</li>
<li>
<p>统计某个用户下进程所有内存 <code>ps -o pid,ppid,pgid,rss,comm  -u deployer | awk '{sum+=$4};END {print sum &quot;K &quot; sum/1024&quot;M &quot;}'</code></p>
</li>
<li>
<p>统计某个应用进程所有内存（自己和所有子进程） <code> </code></p>
</li>
<li>
<p>按内存排序 列出所有进程 <code>ps aux | grep -v RSS | awk &quot;{print $6 &quot;\t&quot; $11 }&quot; | sort --human-numeric-sort -r | less</code></p>
</li>
<li>
<p>按实际执行的二进制命令展示 <code>ps -ely</code></p>
</li>
</ol>
<ul>
<li><a href="https://www.baeldung.com/linux/resident-set-vs-virtual-memory-size">Difference Between Resident Set Size and Virtual Memory Size</a>
<ul>
<li>RSS 驻留内存（共享库+堆+栈） 注意当前进程可能共用别的进程已加载的共享库，所以这部分内存是被重复计算了</li>
<li>VSZ 虚拟内存</li>
</ul>
</li>
</ul>
<h3 id="procs">procs</h3>
<p>Rust 编写的 现代 ps</p>
<h3 id="pstree">pstree</h3>
<blockquote>
<p>顾名思义 树状图展示进程 线程关系</p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/yinzhengjie/p/9998771.html">参考: Linux下查看线程数的几种方法汇总</a></p>
</blockquote>
<hr>
<h2 id="kill">kill</h2>
<ul>
<li>
<p><code>kill -l</code> 或者 <code>trap -l</code>： 输出kill命令可向进程发送的信号</p>
<ul>
<li>kill是通过发送信号让进程自己决定做什么，而不是kill去做什么</li>
<li>那要是有恶意屏蔽信号的进程怎么办？ <code>9号无法屏蔽</code></li>
</ul>
</li>
<li>
<p>kill命令格式<code>kill [选项] [进程号]</code></p>
</li>
<li>
<p>选项:</p>
<ul>
<li>-l 列出所有的信号,如果-l后加上信号名称看到对应的数字,反之亦然</li>
<li>-s 可以指定发出的信号,等同于 -信号 向目标进程发送指定的信号类型</li>
<li>缺省会发送默认的终止信号 <strong>SIGTERM 15</strong></li>
</ul>
</li>
<li>
<p>进程号:</p>
<ul>
<li>大于0: 向目标进程发送指定信号,多个逗号隔开</li>
<li>等于0: 向当前进程组的所有进程发送信号</li>
<li>等于-1: 向除kill进程和init进程(1)之外的所有进程发送信号</li>
<li>小于-1: 向进程组对应的PGID的所有进程发送信号</li>
</ul>
</li>
</ul>
<blockquote>
<p>常用信号量</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">信号名称</th>
<th style="text-align:center">信号编号</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HUP</td>
<td style="text-align:center">1</td>
<td style="text-align:left">终端会话断开，关闭所有其从属的子进程</td>
</tr>
<tr>
<td style="text-align:center">INT</td>
<td style="text-align:center">2</td>
<td style="text-align:left">中断 同<code>Ctrl+C</code> 结束前台进程,输入阻塞的程序应该退出(自己做清理)并清除阻塞状态</td>
</tr>
<tr>
<td style="text-align:center">QUIT</td>
<td style="text-align:center">3</td>
<td style="text-align:left">退出 同<code>Ctrl+\</code> 也有点强制退出的意思</td>
</tr>
<tr>
<td style="text-align:center">FPE</td>
<td style="text-align:center">8</td>
<td style="text-align:left">发生算术运算错误时发出</td>
</tr>
<tr>
<td style="text-align:center">KILL</td>
<td style="text-align:center">9</td>
<td style="text-align:left">强制终止 退出</td>
</tr>
<tr>
<td style="text-align:center">TERM</td>
<td style="text-align:center">15</td>
<td style="text-align:left">终止 程序自己做清理工作,然后退出 <strong>缺省的信号值</strong></td>
</tr>
<tr>
<td style="text-align:center">CONT</td>
<td style="text-align:center">18</td>
<td style="text-align:left">继续 <code>fg/bg</code> 命令</td>
</tr>
<tr>
<td style="text-align:center">STOP</td>
<td style="text-align:center">19</td>
<td style="text-align:left">暂停/停止 同 <code>Ctrl+Z</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://wker.com/linux-command/kill.html">中文释义：全部信号</a> <code>或者直接 man kill</code></p>
</blockquote>
<ul>
<li>9号信号:
<ul>
<li>能对所有的进程起作用, 除了1号init进程</li>
<li>副作用:进程运行中,突然终止,可能会导致系统资源无法释放, 数据没有同步到磁盘等情况(3号就好点)</li>
<li>杀掉指定id（需要sudo）<code>kill -9 pid</code></li>
</ul>
</li>
<li>0号信号:
<ul>
<li>测试信号,测试目标进程是否存在,测试是否具有向指定进程发送信号的权限</li>
</ul>
</li>
</ul>
<hr>
<p><code>Tips</code></p>
<blockquote>
<p>例如 reids的服务端:</p>
</blockquote>
<ul>
<li>INT/TERM 信号就相当于在客户端的shutdown命令,是正常的退出</li>
<li>QUIT/KILL 信号是强制退出</li>
<li>STOP 信号就是暂停挂在后台</li>
</ul>
<blockquote>
<ul>
<li>终结后台作业: 命令格式: <code>kill -信号 %作业号</code>  作业号就是运行<code>jobs</code>后方括号内数字</li>
<li>dmesg 可以查看被Kill的进程的日志</li>
</ul>
</blockquote>
<h3 id="killall">killall</h3>
<blockquote>
<p>通过名字来发送信号,其他和kill是一致的</p>
</blockquote>
<ul>
<li>杀掉指定名字 不需要sudo <code>killall -9 name</code> 要十分谨慎的使用, 避免误杀进程</li>
</ul>
<h2 id="trap">trap</h2>
<blockquote>
<p>捕捉信号并响应
<code>trap &quot;commands&quot; signal-list</code></p>
</blockquote>
<blockquote>
<p>用途</p>
</blockquote>
<ul>
<li>
<p>动态读取并更新配置文件</p>
</li>
<li>
<p>忽略信号对程序可能的影响 <code>trap &quot;&quot; 2</code>: 忽略 <code>Ctrl+C</code></p>
</li>
<li>
<p>可以针对用户的退出操作做hook，询问用户是否真的确认要退出，或者关闭资源，清除临时文件等等</p>
</li>
<li>
<p>屏蔽信号</p>
<ul>
<li><code>trap &quot;&quot; INT</code> 屏蔽中断信号</li>
<li><code>trap INT</code> 恢复</li>
</ul>
</li>
<li>
<p>监控文件的变化，当按下快捷键Ctrl+C 就会执行trap中的命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">    <span class="c1">#!/bin/bash</span>
</span></span><span class="line"><span class="cl">    <span class="nb">trap</span> <span class="s1">&#39;echo &#34;hello&#34;&#39;</span> <span class="m">2</span>
</span></span><span class="line"><span class="cl">    tail -f ~/.bashrc
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<hr>
<h2 id="作业控制">作业控制</h2>
<blockquote>
<p>在Linux中, 作业是由一个或多个进程构成的, 作业控制就是对作业的行为进行控制, 前后台的切换, 终止等操作</p>
</blockquote>
<ul>
<li>常用的操作:
<ul>
<li>命令后的<code>&amp;</code>: 让作业后台运行 作业如果是多个命令构成,会返回最后一个命令对应进程的pid和作业号</li>
<li>Ctrl Z: 作业转到后台并暂停 STOP状态</li>
<li>jobs: 列出当前作业列表</li>
<li>fg: 将一个作业切换到前台并运行</li>
<li>bg: 将一个作业切换到后台并运行</li>
<li>kill: 终止一个作业</li>
</ul>
</li>
<li>前台和后台: 从标准输入读取用户输入, 标准输出展示数据, 后台就是脱离了标准输入和标准输出
<ul>
<li>fg bg 都是会发送具有继续执行的信号</li>
<li>前台切换到后台:
<ul>
<li><code>Ctrl Z</code> 切换到后台,但是会暂停的状态,可以使用<code>jobs</code>查看作业号</li>
<li>再<code>kill -18 %作业</code> 或者 <code>bg %作业号</code></li>
</ul>
</li>
<li>后台切回前台:
<ul>
<li><code>fg %作业</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>指定作业</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%Number</td>
<td style="text-align:left">根据编号来指定作业</td>
<td style="text-align:left">fg %1</td>
</tr>
<tr>
<td style="text-align:left">%String</td>
<td style="text-align:left">匹配命令以String开头的作业,如果匹配到多个就会报错</td>
<td style="text-align:left">kill %deng</td>
</tr>
<tr>
<td style="text-align:left">%?String</td>
<td style="text-align:left">命令行中含有String字符串的作业,如果是通过管道连接的多个命令,则仅匹配第一个命令</td>
<td style="text-align:left">kill %?ng</td>
</tr>
<tr>
<td style="text-align:left">%%</td>
<td style="text-align:left">指代作业列表中最近一个被切换到后台的作业</td>
<td style="text-align:left">kill %%</td>
</tr>
<tr>
<td style="text-align:left">%+</td>
<td style="text-align:left">和%%作用完全相同</td>
<td style="text-align:left">kill %+</td>
</tr>
<tr>
<td style="text-align:left">%-</td>
<td style="text-align:left">排在%%所指代的作业前面的那个作业</td>
<td style="text-align:left">kill %-</td>
</tr>
</tbody>
</table>
<blockquote>
<p>也就是说,这个匹配也是只能匹配一个作业,不能通配使用</p>
</blockquote>
<h2 id="守护进程">守护进程</h2>
<blockquote>
<p>使得普通命令启动的进程变成类似于守护进程的工具</p>
</blockquote>
<p>两种方案:</p>
<ul>
<li>让进程对hup信号免疫 nohup disown</li>
<li>让进程在新的会话中运行 setid screen</li>
</ul>
<h3 id="nohup">nohup</h3>
<ul>
<li>在命令前 加上hohup
<ul>
<li>忽略所有hup信号 并将标准输出重定向到 nohup.out 若当前目录不可写，就会重定向到 $HOME/nohup.out</li>
</ul>
</li>
<li>nohup 命令&gt;result.txt 2&gt;&amp;1
<ul>
<li><code>2&gt;&amp;1</code> 表示将标准错误(2)重定向到标准输出(1)</li>
<li>将标准输出(1)重定向到 result.txt</li>
<li>等同于 <code>nohup 命令&gt;result.txt 2&gt;/dev/null 1&gt;&amp;2 &amp;</code></li>
<li>命令运行到后台， PID=$! 得到子进程ID</li>
<li>得到ID后 通过执行这两条命令得到原命令的返回值<code>wait $PID</code> <code>echo $?</code></li>
<li>一般返回值就是原命令的返回值，但是特殊：</li>
<li>125 nohup命令失败，并且POSIXLY_CORRECT环境变量没有设置</li>
<li>126 指定命令能找到，但是不能调用</li>
<li>127 找不到指定命令</li>
</ul>
</li>
</ul>
<h3 id="disown">disown</h3>
<ul>
<li>执行中的命令，Ctrl+Z 暂停到后台去了 jobs查看作业编号</li>
<li><code>disown %作业号</code> 就能在后台运行，且屏蔽hup信号了</li>
</ul>
<h3 id="setid">setid</h3>
<ul>
<li>命令前 <code>setid 命令</code> 就会让进程在一个新的会话运行</li>
</ul>
<h3 id="screen">screen</h3>
<blockquote>
<p>在一个真实的终端运行多个伪终端，认为是开启了多个新会话 <a href="http://man.linuxde.net/screen">命令参考</a></p>
</blockquote>
<ul>
<li>会话恢复
<ul>
<li>只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。</li>
<li>只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。</li>
</ul>
</li>
<li>多窗口
<ul>
<li>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等；</li>
<li>还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。 会话共享 Screen可以让一个或多个用户从不同终端多次登录一个会话，</li>
<li>并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">verb</th>
<th style="text-align:center">param</th>
<th style="text-align:left">comment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-A</td>
<td style="text-align:center">　</td>
<td style="text-align:left">将所有的视窗都调整为目前终端机的大小。</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td style="text-align:center">&lt;作业名称&gt;</td>
<td style="text-align:left">　将指定的screen作业离线。</td>
</tr>
<tr>
<td style="text-align:center">-h</td>
<td style="text-align:center">&lt;行数&gt; 　</td>
<td style="text-align:left">指定视窗的缓冲区行数。</td>
</tr>
<tr>
<td style="text-align:center">-m</td>
<td style="text-align:center">　</td>
<td style="text-align:left">即使目前已在作业中的screen作业，仍强制建立新的screen作业。</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">&lt;作业名称&gt;</td>
<td style="text-align:left">　恢复离线的screen作业。</td>
</tr>
<tr>
<td style="text-align:center">-R</td>
<td style="text-align:center">　</td>
<td style="text-align:left">先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td style="text-align:center">　</td>
<td style="text-align:left">指定建立新视窗时，所要执行的shell。</td>
</tr>
<tr>
<td style="text-align:center">-S</td>
<td style="text-align:center">&lt;作业名称&gt;</td>
<td style="text-align:left">　指定screen作业的名称。</td>
</tr>
<tr>
<td style="text-align:center">-v</td>
<td style="text-align:center">　</td>
<td style="text-align:left">显示版本信息。</td>
</tr>
<tr>
<td style="text-align:center">-x</td>
<td style="text-align:center">　</td>
<td style="text-align:left">恢复之前离线的screen作业。</td>
</tr>
<tr>
<td style="text-align:center">-ls或&ndash;list</td>
<td style="text-align:center"></td>
<td style="text-align:left">　显示目前所有的screen作业。</td>
</tr>
<tr>
<td style="text-align:center">-wipe</td>
<td style="text-align:center">　</td>
<td style="text-align:left">检查目前所有的screen作业，并删除已经无法使用的screen作业。</td>
</tr>
</tbody>
</table>
<h2 id="ipc">IPC</h2>
<blockquote>
<p>进程间通信: 管道/信号量/共享内存/Socket</p>
</blockquote>
<hr>
<h1 id="系统管理">系统管理</h1>
<h2 id="uname">uname</h2>
<ul>
<li><code>uname -a</code> 输出所有信息
<ul>
<li>-s 内核名称</li>
<li>-n 主机名称</li>
<li>-r 内核发行版号</li>
<li>-v 操作系统具体版本</li>
<li>-m 机器硬件名称</li>
<li>-p 处理器名称</li>
<li>-i 硬件平台名称</li>
<li>-o 操作系统名称</li>
</ul>
</li>
</ul>
<h2 id="who">who</h2>
<ul>
<li>
<p><code>who</code> 和 <code>w</code>  who是按照不同tty来显示信息</p>
<ul>
<li>查看系统的真实用户，</li>
<li>例如当普通用户 使用su 切换用户，这条命令就显示了真正的用户，而不是su切换后的用户</li>
</ul>
</li>
<li>
<p><code>whoami</code> 查看有效用户，就是当前会话的拥有者</p>
</li>
<li>
<p><code>groups</code> 查看所有组</p>
</li>
</ul>
<h2 id="service">service</h2>
<ul>
<li>
<p><code>service 服务名 status/start/stop/restart</code></p>
</li>
<li>
<p>查看所有service掌控的服务 <code>cd /etc/init.d/ &amp;&amp; ls -F</code></p>
</li>
<li>
<p><code>which service</code> 结果显示这是个脚本</p>
</li>
<li>
<p><code>service 服务名 stop</code> 等价于 <code>/etc/init.d/服务名 stop</code></p>
</li>
</ul>
<h2 id="chkconfig">chkconfig</h2>
<blockquote>
<p>掌控等级制度 LSB</p>
</blockquote>
<h2 id="dmidecode">dmidecode</h2>
<blockquote>
<p>输出机器的 BIOS CPU 内存等硬件信息 （DMTF DMI）</p>
</blockquote>
<ul>
<li>运行 <code>dmidecode -t </code>就会提示你后接类别</li>
</ul>
<h2 id="lsmod">lsmod</h2>
<blockquote>
<p>Show the status of modules in the Linux Kernel</p>
</blockquote>
<h2 id="chroot">chroot</h2>
<blockquote>
<p>change root directory 更改root目录 最古老的容器技术</p>
</blockquote>
<ul>
<li><code>mkdir 目录 </code> 复制相关目录过来，就能把系统迁移过来了</li>
<li><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p262.jpg" alt="p262"></li>
<li><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p263.jpg" alt="p263"></li>
<li><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p264.jpg" alt="p264"></li>
<li><img src="https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Linux_DaPeng_mingling100/p265.jpg" alt="p265"></li>
</ul>
<h1 id="关机重启">关机/重启</h1>
<blockquote>
<p>shutdown | reboot | halt | poweroff | init</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">shutdown</td>
<td style="text-align:left">可用于关机，重启，支持定时和通知</td>
</tr>
<tr>
<td style="text-align:left">reboot</td>
<td style="text-align:left">重启系统</td>
</tr>
<tr>
<td style="text-align:left">halt</td>
<td style="text-align:left">停止系统</td>
</tr>
</tbody>
</table>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Kuangcp</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-12-15
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/linux/base/linuxproblem/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Linux桌面发行版遇到的问题</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/linux/base/linuxnetwork/">
            <span class="next-text nav-default">Linux网络管理</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/Kuangcp" class="iconfont icon-github" title="github"></a>
  <a href="https://www.kuangcp.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://gitee.com/gin9/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span>
    <span>Kuangcp</span>
    
    <br/><span><a href='http://beian.miit.gov.cn/'; target=_blank>www.kuangcp.top</a></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh-cn".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>






</body>
</html>
